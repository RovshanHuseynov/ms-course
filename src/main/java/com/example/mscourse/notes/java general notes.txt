Integer a = 4;
Integer b = 4;
System.out.println(a == b); // true

Integer a = 128;
Integer b = 128;
System.out.println(a == b); // false


between -128 to 127 they are true, then they are false. byte-Ä±n tutduÄŸu yer É™n kiÃ§ikdir, bu o demÉ™kdir byte-Ä±n tutduÄŸu yer digÉ™r hamÄ±sÄ±nÄ± tutduÄŸu yerÉ™ girib yerlÉ™ÅŸÉ™ bilÉ™r. short-da yerlÉ™ÅŸÉ™ bilÉ™r, int-É™ dÉ™, long-a da. HamÄ±sÄ±na yerlÉ™ÅŸÉ™ bilir deyÉ™, onu keÅŸlÉ™yÉ™ bilir, daha bÃ¶yÃ¼k rÉ™qÉ™mlÉ™ri isÉ™ keÅŸlÉ™mir ki, onlar sonra misal Ã¼Ã§Ã¼n byte-a short-a yerlÉ™ÅŸmÉ™yÉ™ bilÉ™r

Gradle vs Maven
1. Gradle bir az daha sÃ¼rÉ™tli iÅŸlÉ™yir. Dependency-lÉ™ri daha tez gÉ™tirir (tÉ™bii ki internetin sÃ¼rÉ™ti dÉ™ burda Ã¶nÉ™mli faktordur)
2. Gradle-da Ã¶z scriptlÉ™rimizi yazmaq olur

failSafe()
failFast()
iteratorlarn fÉ™rqi
MultiThread collections
misal Ã¼Ã§Ã¼n ArrayList() yox CopyOnWriteArrayList() - bu saÄŸdakÄ±nÄ± iÅŸlÉ™dÉ™ndÉ™ bizim iterator artÄ±q failSafe olmuÅŸ olur
map yox ConcurrentHashMap. bunlar multi thread mÃ¼hittÉ™ listlÉ™rlÉ™ vÉ™ ya maplarla iÅŸlÉ™mÉ™k Ã¼Ã§Ã¼ndÃ¼r

Java 8 gÉ™lmÉ™miÅŸdÉ™n Ã¶ncÉ™ (yÉ™ni lambda gÉ™lmÉ™miÅŸdÉ™n Ã¶ncÉ™) functional interface-lÉ™r Java-ne nÉ™ vasitÉ™silÉ™ istifadÉ™ olunurdu? cavab: anynom class-lar vasitÉ™silÉ™ 
lambda expression-a int a Ã¶tÃ¼rÉ™ bilmirik, orda immutibility mÉ™sÉ™lÉ™si var, lambda expression-a effectively final variable gÃ¶ndÉ™rÉ™ bilirik. bunun mÉ™qsÉ™di variable-Ä± sadÉ™cÉ™ bir dÉ™fÉ™ istifadÉ™ etmÉ™k Ã¼Ã§Ã¼ndÃ¼r. int ona gÃ¶rÉ™ gÃ¶ndÉ™rÉ™ bilmirikki, int final deyil.

java 8-dÉ™n sonra bucket red black tree-dir linkedlist yox, amma size > 8 olandan sonra red black tree-yÉ™ Ã§evrilir, size = 8-É™ kimi linkedlist olmaÄŸa davam edir
red black tree-dÉ™ axtarÄ±ÅŸ O(log(n))-dir deyÉ™sÉ™n binary search-lÉ™r iÅŸlÉ™yir
sonra load factor default olaraq 75%-dir, onu aÅŸandan sonra bucket size 2 dÉ™fÉ™ artÄ±r (default = 16)
sual? mapdakÄ± elementlÉ™ri silsÉ™k onda bucket size azalÄ±rmÄ±? cavab: xeyr. elÉ™ size neÃ§É™dirsÉ™ o cÃ¼r dÉ™ qalÄ±r. bu bizÉ™ memory leak yarada bilÉ™r. diqqÉ™tli olmaq lazÄ±mdÄ±r.
biz mÃ¼tlÉ™q azalmasÄ±nÄ± istÉ™yiriksÉ™ onda Ã¶z hashmapÄ±mÄ±zÄ± yazmalÄ±yÄ±q. bu hallarda javanÄ±n standart hashmapÄ± bizÉ™ yaramÄ±r

hashlarÄ±n eyni olmasÄ±na termin olaraq kolleziya deyilir.

final vs effectively final
final-da variable qarÅŸÄ±sÄ±na final yazÄ±rÄ±q vÉ™ bilirik ki, dÉ™yÉ™r-value heÃ§ vaxt dÉ™yiÅŸmÉ™yÉ™cÉ™k
effectively final-da isÉ™ variable qarÅŸÄ±sÄ±na final yazmÄ±rÄ±q, amma dÉ™yÉ™ri bir dÉ™fÉ™ yazÄ±rÄ±q vÉ™ heÃ§ vaxt dÉ™yiÅŸmir

Amotic class-lar Ã¶zlÉ™ri arxada volatile keyword istifadÉ™ edirlÉ™r, yÉ™ni dÉ™yÉ™ri keÅŸdÉ™n Ram-dan gÃ¶tÃ¼rÃ¼r. MultiThread-dÉ™ mÉ™cbur Atomic variable iÅŸlÉ™tmÉ™liyik, Ã§Ã¼nki multi thread-dÉ™ int onsuz da iÅŸlÉ™mÉ™yÉ™cÉ™k.

iterator vs listiterator

in listiterator, you can:
- iterate backwards
- obtain the iterator at any point.
- add a new value at any point.
- set a new value at that point.

With iterator you can move only forward, but with ListIterator you can move backword also while reading the elements.
With ListIterator you can obtain the index at any point while traversing, which is not possible with iterators.
With iterator you can check only for next element available or not, but in listiterator you can check previous and next elements.
With listiterator you can add new element at any point of time, while traversing. Not possible with iterator.
With listiterator you can modify an element while traversing, which is not possible with iterator.

Atomic classlar multi thread applarda mÃ¼tlÉ™q ki, istifadÉ™ olunmalÄ±dÄ±r vÉ™ onlar arxa planda Ã¶zlÉ™ri multi thread Ã¼Ã§Ã¼n nÉ™zÉ™rdÉ™ tutulub. Misal Ã¼Ã§Ã¼n orda volatile istifadÉ™ olunub. YÉ™ni dÉ™yÉ™rlÉ™r keÅŸdÉ™n yox birbaÅŸa RAM-dan gÃ¶tÃ¼rÃ¼lÃ¼r. Multi thread appda biz bu atomic classlarÄ±n obyektini iÅŸlÉ™tmÉ™liyik.
Misal Ã¼Ã§Ã¼n deyÉ™k ki, tiktokda iki meyxanaÃ§Ä± canlÄ± yayÄ±mda meyxana deyib yarÄ±ÅŸÄ±rlar vÉ™ sÉ™n dÉ™ kimi dÉ™stÉ™klÉ™yirsÉ™nsÉ™ girib o meyxanaÃ§Ä±ya sÉ™s verirsÉ™n. DeyÉ™k ki, hÉ™r meyxanaÃ§Ä± Ã¼Ã§Ã¼n dÉ™ ekranda 1 É™dÉ™d dÃ¼ymÉ™ var. "MexyanaÃ§Ä±A-ni dÉ™skÉ™tlÉ™!" "MexyanaÃ§Ä±B-ni dÉ™skÉ™tlÉ™!" adÄ±nda 2 É™dÉ™d button var. Ä°ndi canlÄ± yayÄ±mda minlÉ™rlÉ™ istifadÉ™Ã§i o dÃ¼ymÉ™lÉ™ri girib klik edirlÉ™r vÉ™ hÉ™r meyxanaÃ§Ä±ya neÃ§É™ nÉ™fÉ™r sÉ™s verib biz onu hesablamalÄ±yÄ±q. DeyÉ™k ki, bizim int cnt = 0; dÉ™yiÅŸÉ™nimiz var hÉ™r azarkeÅŸ klik edÉ™ndÉ™ cnt++ yazÄ±rÄ±q. Multi thread appda tÉ™bii ki bu iÅŸlÉ™mÉ™yÉ™cÉ™k, eyni anda iki vÉ™ daha Ã§ox azarkeÅŸ klik etsÉ™ vsyo bizim cnt keÅŸdÉ™n gÃ¶tÃ¼rÉ™cÉ™k tutaq ki 10 nÉ™fÉ™r eyni ayna klik edÉ™ndÉ™ amma bizim cnt 1 vahid vÉ™ ya nÉ™bilim 3 vahid artmÄ±ÅŸ olacaq, halbuki 10 vahid artmalÄ± idi. Burda mÃ¼tlÉ™q ki, AtomicInteger iÅŸlÉ™tmÉ™li idik onda o Ã¶zÃ¼ volatile istifadÉ™ edir deyÉ™ eyni anda neÃ§É™ nÉ™fÉ™r dÉ™ klik etsÉ™ o sayda increment olacaqdÄ±.

AtomicInteger nÉ™ zaman istifadÉ™ edilÉ™ bilir? multithreadingdÉ™. shared datamÄ±z varsa. stackda saxlanmayan datadÄ±rsa yani method iÃ§indÉ™ki variabledirsÉ™ ehtiyac deyil bunlarda, amma classda É™n yuxarÄ±da (methodlardan da yuxarÄ±da) olan variabledÄ±rsa onda lazÄ±mdÄ±r. Ã§Ã¼nki onlar arxada volatile iÅŸlÉ™dir, methodlarÄ± safe methodlardÄ±r, yÉ™ni mÉ™lumatÄ± keÅŸdÉ™n yox RAMdan gÃ¶tÃ¼rÃ¼r


Volatile-nin dÉ™ demiÅŸdik mÉ™nfi cÉ™hÉ™ti oldurki nisbÉ™tÉ™n zÉ™if sÃ¼rÉ™tdÉ™ iÅŸlÉ™yirlÉ™r, amma Multi thread applarda onlarÄ± iÅŸlÉ™tmÉ™yÉ™ mÉ™cburuq, baÅŸqa yolumuz yoxdur onsuzda. ÆslindÉ™ AtomicInteger int-É™ nisbÉ™tdÉ™ bÉ™li gec iÅŸlÉ™yir, amma onun kodunu elÉ™ optimal yazÄ±blarki É™slindÉ™ o qÉ™dÉ™r dÉ™ gec iÅŸlÉ™mir, yÉ™ni iÅŸimizi gÃ¶rÃ¼r, problem yoxdur.

Volatile Ã¼Ã§Ã¼n internetdÉ™ qÉ™ÅŸÉ™ng nÃ¼munÉ™ var ki, biz tutaqki evdÉ™ oturmuÅŸuq divanda pivÉ™ iÃ§mÉ™k istÉ™yirik. YanÄ±mÄ±zda balaca soyuducular olur ee portable, ondan var onun iÃ§indÉ™ pivÉ™ var, onu gÃ¶tÃ¼rÃ¼b iÃ§irik. Bu birinci hal. Sonra mÉ™tbÉ™xdÉ™ soyuducuda da pivÉ™ var onu da gedib gÉ™tirib iÃ§É™ bilÉ™rdik. Bu ikinci hal. Bir dÉ™ Ã§Ã¶ldÉ™ yaxÄ±nlÄ±qda market var orda da soyuducuda pivÉ™ satÄ±rlar gedib onu alÄ±b onu da iÃ§É™ bilÉ™rdik. Bu Ã¼Ã§Ã¼ncÃ¼ hal. Ä°nternetdÉ™ki nÃ¼munÉ™dÉ™ deyirdiki biz kodda volatile yazanda gedib pivÉ™ni o Ã§Ã¶ldÉ™ki marketdÉ™ki soyuducudan gÉ™tirir, yÉ™ni uzaqdan gÉ™tirir RAM-dan. O nÃ¼munÉ™dÉ™ keÅŸ isÉ™ bizim yanÄ±mÄ±zda onu xÄ±rda portable soyuducu idi ğŸ˜€

HansÄ± class-Ä±n obyektini yaratmaq olmur? - Abstract class
Constructoru var? - var
niyÉ™? - Ã§Ã¼nki onu extend edÉ™n class-Ä±n obyekti yaradÄ±landa hÉ™min classÄ±n constructoru iÅŸÉ™ dÃ¼ÅŸÃ¼r vÉ™ inheritance qaydasÄ±na gÃ¶rÉ™ hÉ™min constructorun iÃ§É™risindÉ™ abstract classÄ±n constructoru da iÅŸÉ™ dÃ¼ÅŸmÉ™lidir

bir class-Ä± immutable etmÉ™k Ã¼Ã§Ã¼n nÉ™ etmÉ™k lazÄ±mdÄ±r?
1. classÄ± final elÉ™
2. field-lÉ™r private
3. setter-lÉ™ri yÄ±ÄŸÄ±ÅŸdÄ±r
4. getter-lÉ™rdÉ™ É™gÉ™r mutable obyekt qayÄ±dÄ±rsa onu clonlayÄ±rÄ±q. SÉ™bÉ™bi dÉ™ odurki, É™gÉ™r obyekti girib dÉ™yiÅŸsÉ™lÉ™r belÉ™ bizÉ™ tÉ™sir etmÉ™yÉ™cÉ™k, Ã§Ã¼nki biz obyektin Ã¶zÃ¼nÃ¼ yox clonunu qaytarÄ±rÄ±q

constructoru private harda etmÉ™k olar?
1. singleton class-larda
2. constant class-larda. yalnÄ±z field-lÉ™r olur onlarda da public static final olur. Class-Ä±n obyektini yaratmaÄŸa ehtiyac olmur

try with resources - exception handling zamanÄ± istifadÉ™ olunur. finally block-un alternatividir. finally block-unu avtomatik Ã¶zÃ¼ icra edir, amma yalnÄ±z AutoClonable interface-sini implements edÉ™n resursdursa onda try with resources istifadÉ™ edÉ™ bilirik. try with resources finally blockundan daha Ã¼stÃ¼n hesab edilir, Ã§Ã¼nki finally blockunun iÃ§indÉ™ dÉ™ exception Ã§Ä±xa bilÉ™r gÉ™rÉ™k onu da Ã¶zÃ¼mÃ¼z handle edÉ™k, amma try with resources-da o iÅŸlÉ™ri gÃ¶rmÉ™li olmuruq.

Thread yaratmaÄŸÄ±n hansÄ± Ã¼sullarÄ± var?
1. Thread classÄ±ndan extends etmÉ™k
2. Runnable interface implements etmÉ™k
3. Callable interface implements etmÉ™k
Runnable ilÉ™ Callable nÉ™ fÉ™rqi var? qaytardÄ±ÄŸÄ± tipdÉ™ fÉ™rqi var
HÉ™r ikisi functional interfacedir, yÉ™ni yalnÄ±z 1 É™dÉ™d abstract methodu var
Runnable interface-dÉ™ki hÉ™min o method void-dir yÉ™ni dÉ™yÉ™r qaytarmÄ±r
Callable interface-dÉ™ki method isÉ™ Future obyekt qaytarÄ±r. Bunda threadi buraxandan sonra cavabÄ± izlÉ™mÉ™k olur, axÄ±rÄ± nÉ™ oldu bilmÉ™k olur
CompletableFuture in Java AraÅŸdÄ±r

sual: OOP encapsulation-u nÉ™ ilÉ™ sÄ±ndÄ±rmaq olar? cavab: reflection ilÉ™
encapsulation yÉ™ni ki, set()-lÉ™ri yÄ±ÄŸÄ±ÅŸdÄ±rmaq, variableyÉ™ dÉ™yÉ™ri yalnÄ±z constructorda vermÉ™k.

HansÄ± classlarÄ± immutable etmÉ™liyik? Cavab: ???
NiyÉ™ deyirikki, class-da immutable olsun, yÉ™ni fieldlÉ™rimiz private olsun vÉ™ s? yÉ™ni Cavab: multithread-ing zamanÄ± problem yaÅŸamayaq deyÉ™

current table-ya index qoysaq cÉ™dvÉ™l lock olacaq. gÉ™rÉ™k gecÉ™ serveri sÃ¶ndÃ¼rÃ¼b qoyaq neÃ§É™ saat production iÅŸlÉ™mÉ™sin. postgresql-dÉ™ asyncron index var, cÉ™dvÉ™li lock etmÉ™miÅŸ index qoyur
primary key vÉ™ unique constraintlÉ™ri avtomatik index yaradÄ±r
serial vÉ™ bigserial Ã¶zÃ¼ndÉ™ increment saxlayÄ±r

Transaction
ACID principles:
1. Atomicity - ya transaction fully olaraq keÃ§mÉ™lidir, fully rollback olmalÄ±dÄ±r
2. Consistency - data consistentliyi pozulmamalÄ±dÄ±r, cÉ™dvÉ™llÉ™r - tÉ™rÉ™flÉ™r arasÄ±nda state eyni qalmalÄ±dÄ±r, pozulmamalÄ±dÄ±r, yÉ™ni bir tÉ™rÉ™fdÉ™ status CompleteddirsÉ™, digÉ™r tÉ™rÉ™fdÉ™ dÉ™ completed olmalÄ±dÄ±r vÉ™ ya bir tÉ™rÉ™fdÉ™ mÉ™blÉ™ÄŸ 5 manatdÄ±rsa digÉ™r tÉ™rÉ™fdÉ™ dÉ™ 5 manat olmaldÄ±r. Misal Ã¼Ã§Ã¼n sÉ™n 5 manat gÃ¶ndÉ™rdin, qarÅŸÄ± tÉ™rÉ™fÉ™ 6 manat getdi Ã§atdÄ± bu o demÉ™kdirki consistency pozulub
3. Isolation - kÉ™nar mÃ¼daxilÉ™ olmamalÄ±dÄ±r, digÉ™r bir transaksiya filan bura qoÅŸulmamalÄ±dÄ±r. DigÉ™r É™mÉ™liyyat varsa ikinci bir transaksiya kimi edilmÉ™lidir
4. Durability - safe ÅŸÉ™kildÉ™ proses bitir. bir transaction commit olunubsa yÉ™ni proses bitibsÉ™ artÄ±q bu andan sonra bu transaksiya barÉ™sindÉ™ heÃ§ bir dÉ™yiÅŸiklik edilÉ™ bilmÉ™z, rollback oluna bilmÉ™z vÉ™ s.
Sual: Durability nÉ™ vaxt pozula bilÉ™r? bir nÃ¼munÉ™ de. Cavab: Databaza hÉ™miÅŸÉ™ bir É™dÉ™d olmur. Bizim yazdÄ±ÄŸÄ±mÄ±z master databazadÄ±r, amma onun replicasiyasÄ± olur, standy filan olur. buna databazada Sharding (standby databaza, replica databaza) deyilir. Durability belÉ™ pozula bilÉ™r ki, biz master db-yÉ™ yazdÄ±q OK cavabÄ±nÄ± aldÄ±q, elÉ™ bildik bizim transaksiya bitdi. Amma hÉ™min data standy-a dÃ¼ÅŸmÉ™disÉ™ onda durability pozulmuÅŸ olur. Replicasiya mÉ™ntiqi 2 cÃ¼r ola bilÉ™r. Sinxron vÉ™ Asinxron. Durability-ni pozmamaq Ã¼Ã§Ã¼n biz replicasiya mÉ™ntiqini sinxron qoymalÄ±yÄ±q. Asinxron qoysaq durability pozula bilÉ™r.

Default profile adÄ±: "default". kodda yazanda @Profile("default")
Active Profile. misal Ã¼Ã§Ã¼n necÉ™ etmÉ™k olar ki, local profile-dÉ™ feign-dÉ™ki url-i Ã§aÄŸÄ±rmasÄ±n. É™vÉ™zindÉ™ nÉ™sÉ™ static bir ÅŸey qaytarsÄ±n?
Feign client bir interface olduÄŸuna gÃ¶rÉ™ tÉ™zÉ™ bir mock class yazadÄ±b feign interface-ni implements edib (tÉ™bii ki classÄ± springÉ™ bean kimi tanÄ±tdÄ±rmaq Ã¼Ã§Ã¼n yuxarÄ±ya @Component yazmaq Ã§ox vacibdir), hÉ™min mock class-da feign interfacedÉ™ki methodumuzun eynisini override ilÉ™ Ã§aÄŸÄ±rÄ±b, return static data qaytara bilÉ™rik. Misal Ã¼Ã§Ã¼n return data type Student idisÉ™, return Student.builder().name("test").surname("test").build(); yaza bilÉ™rik. belÉ™ olanda hÉ™min class-Ä±n Ã¼stÃ¼nÉ™ @Profile("local") yazÄ±rÄ±q, feign interface-yÉ™ isÉ™ @Profile("!local") yazÄ±rÄ±q

Application fayllarÄ±mÄ±zÄ±n bir bir ayÄ±rÄ±b Ã§oxlu .yml fayl yaratmaq istÉ™mÉ™sÉ™k, onda secrets-lÉ™rdÉ™n istifadÉ™ edÉ™ bilÉ™rik. Secrets-lÉ™r adÄ±ndan gÃ¶rÃ¼ndÃ¼yÃ¼ kimi secret olan (yÉ™ni heÃ§ kimi gÃ¶rmÉ™li olmayan, sensitive) datalarÄ± gizlÉ™tmÉ™k Ã¼Ã§Ã¼ndÃ¼r. Misal Ã¼Ã§Ã¼n application.yml faylÄ±nda databazanÄ±n IP-port-username-password-larÄ±nÄ± heÃ§ kim gÃ¶rmÉ™mÉ™lidir aÃ§Ä±q ÅŸÉ™kildÉ™ saxlaya bilmÉ™rik. bunu secrets kimi saxlamalÄ±yÄ±q. application properties-dÉ™ hÉ™min hissÉ™lÉ™ri variable kimi dollar iÅŸarÉ™si kimi qoyuruq vÉ™ variable-in dÉ™yÉ™rini (value) baÅŸqa bir yerdÉ™ set edirik. ${db.url} buna secrets deyilir. ${db.url} prod mÃ¼hit Ã¼Ã§Ã¼n baÅŸqadÄ±r, alfa mÃ¼hit Ã¼Ã§Ã¼n baÅŸqa, local Ã¼Ã§Ã¼n baÅŸqa. Ya 3 fÉ™rqli application.yml yaratmalÄ± idik, ya da secrets-lÉ™r ilÉ™ iÅŸi hÉ™ll edÉ™ bilÉ™rik.
secrets-lÉ™rin dÉ™yÉ™rini ya Kubernetes-dÉ™ (bu Ã¼sul mÉ™slÉ™hÉ™t deyil, Ã§Ã¼nki KubernetesdÉ™ bunlar sadÉ™cÉ™ base64 formada saxlanÄ±lÄ±r vÉ™ tam tÉ™hlÃ¼kÉ™siz deyil, zÉ™if security), ya Vault-da (Vault = Secret Management Tool, bu Ã¼sul mÉ™slÉ™hÉ™tlidir burda secrets-lÉ™r tÉ™hlÃ¼kÉ™siz formada saxlanÄ±lÄ±r), ya gitlabda Ã¶tÃ¼rÉ™ bilÉ™rik.
secrets iÅŸlÉ™diriksÉ™ bÉ™s onda kodu Ã¶zÃ¼mÃ¼z localda necÉ™ run edirik? secrets-lÉ™ri localda necÉ™ set edirik? cavab: set etmirik. birdÉ™nÉ™ application-local.yml yaradÄ±rÄ±q, orda secrets yox Ã¶zÃ¼mÃ¼z É™llÉ™ aÃ§Ä±q ÅŸÉ™kildÉ™ yazÄ±rÄ±q.

secrets-lÉ™rlÉ™ baÅŸqa nÉ™ etmÉ™k olar?
misal Ã¼Ã§Ã¼n sizdÉ™ kodda bir hissÉ™ var ki, onu bÉ™zi kÉ™nar nÃ¼anslara gÃ¶rÉ™ ya enable ya da disable etmÉ™k istÉ™yirsiz. vÉ™ ya komisiya var onu hansÄ±sa ÅŸÉ™rtdÉ™ 10%, hansÄ±sa ÅŸÉ™rtdÉ™ 15%, sonra tÉ™zdÉ™ 10%-É™ qaytar etmÉ™k istÉ™yirsiz. yÉ™ni tez-tez vÉ™ hansÄ±sa kÉ™nar bir sÉ™bÉ™bÉ™ gÃ¶rÉ™ (ÅŸirkÉ™tin kampaniyasÄ±, hansÄ±sa bir aksiya vÉ™ s) ordakÄ± variable dÉ™yiÅŸmÉ™lidir. secrets ilÉ™ bunu edÉ™ bilÉ™rik.
yml faylÄ±nda enable : commission : ${ENABLE_COMISSION} - qoyub, dÉ™yÉ™ri true-false kimi kÉ™nardan (Vault, Kubernetes, Gitlab) Ã¶tÃ¼rÉ™ bilÉ™rsiz
vÉ™ yÉ™ commissionPercentage : ${COMISSION_PERCENTAGE} - qoyub, dÉ™yÉ™ri 10-15-sonra yenidÉ™n 10 kimi kÉ™nardan (Vault, Kubernetes, Gitlab) Ã¶tÃ¼rÉ™ bilÉ™rsiz
sonra kodda if ilÉ™ dÉ™ ${ENABLE_COMISSION} = true yoxsa false olmaÄŸÄ±nÄ± yoxlaya bilÉ™rik. vÉ™ ya bu hallarda @ConditionalOnProperty() annotation iÅŸlÉ™dÉ™ bilÉ™rik. bu annotationu servis classÄ±nin Ã¼zÉ™rinÉ™ qoyuruq. misal Ã¼Ã§Ã¼n orda @ConditionalOnProperty(${ENABLE_COMISSION} = true) versÉ™k, yalnÄ±z ENABLE_COMISSION = true ÅŸÉ™rtindÉ™ spring bu servisi bean kimi gÃ¶rÃ¼b inject edÉ™cÉ™k.
secrets-lÉ™r KubernetesdÉ™ base64 ÅŸifrÉ™lÉ™nib saxlanÄ±lÄ±r. YÉ™ni biz ora nÉ™sÉ™ value yazmaq istÉ™sÉ™k onu ora ÅŸifrÉ™lÉ™yib yazmalÄ±yÄ±q, hÉ™mÃ§inin oxuyanda da ÅŸifrÉ™ni aÃ§Ä±q oxumalÄ±yÄ±q. ÆgÉ™r bizdÉ™ sensitive data deyilsÉ™, misal Ã¼Ã§Ã¼n COMISSION_PERCENTAGE 10/15/20-ni saxlayÄ±rÄ±qsa vÉ™ ÅŸifrÉ™lÉ™mÉ™yÉ™ vaxt sÉ™rf etmÉ™k istÉ™miriksÉ™ onda Kubernetes-dÉ™ config map anlayÄ±ÅŸÄ± var. Bu ÅŸifrÉ™lÉ™mÉ™k lazÄ±m olmayan datalarÄ± secrets-lÉ™rdÉ™ yox config map-larda saxlayÄ±rÄ±q.

Ingress - xarici dÃ¼nyaya Ã¶z APP-nÄ± hansÄ± yollarla aÃ§Ä±rsan. bizim appÄ±n Ã§Ã¶lÉ™ aÃ§Ä±lan hissÉ™lÉ™ri, Ã§Ã¶lÉ™ aÃ§Ä±q olan ms-lÉ™r / API-lar. yÉ™ni Ã§Ã¶ldÉ™n Ã§aÄŸÄ±rÄ±lmasÄ± mÃ¼mkÃ¼n olan, yÉ™ni public API-lar. Ã§Ã¶l dediyimiz front ola bilÉ™r vÉ™ ya third-party kÉ™nar ÅŸirkÉ™tlÉ™r ola bilÉ™r. DigÉ™r-internal API-lar isÉ™ ingress-É™ qoÅŸulmur. Misal Ã¼Ã§Ã¼n hansÄ± ms-lÉ™r ingress-É™ heÃ§ vaxt qoÅŸulmamalÄ±dÄ±r? cavab: adapter ms-lÉ™r. AdapterlÉ™r adÉ™tÉ™n internal ms-lÉ™r olurlar, yÉ™ni yalnÄ±z daxildÉ™n Ã§aÄŸÄ±rÄ±lÄ±rlar.
Kubernetes - arkestr. bÃ¼tÃ¼n ms-lÉ™ri arkestr edir, kordinasiya edir.
Kubernetes-dÉ™ liveness vÉ™ readiness anlayiÅŸlarÄ± var. liveness odurki sÄ±rf ms ayaqdadÄ±r yoxsa yox onu yoxlamaq. Onu da tÉ™bii ki bizim yazdÄ±ÄŸÄ±mÄ±z HealthCheck API-larÄ± Ã§aÄŸÄ±rÄ±b o response-yÉ™ É™sasÉ™n bilir. Readiness isÉ™ odurki, pod tam olaraq sorÄŸularÄ± qÉ™bul etmÉ™k Ã¼Ã§Ã¼n hazÄ±rdÄ±rmÄ±. Readiness É™sasÉ™n HPA-lar zamanÄ± istifadÉ™ olunur, yÉ™ni misal Ã¼Ã§Ã¼n bizdÉ™ 10 pod idi, idi load vaxtÄ± HPA etdik qaldÄ±rdÄ±q 20 poda, amma hÉ™min o 10 É™dÉ™d tÉ™zÉ™ podlar elÉ™ hÉ™min an sorÄŸularÄ± qÉ™bul etmÉ™k Ã¼Ã§Ã¼n hazÄ±r olmurlar, ms-lÉ™r run olmalÄ±dÄ±r vÉ™ s, readiness bunu yoxlayÄ±r, pod nÉ™ vaxt sorÄŸularÄ± qÉ™bul etmÉ™k Ã¼Ã§Ã¼n tam hazÄ±r olsa onda readiness=true olur vÉ™ Kubernetes hÉ™min anda hÉ™min podlara da trafik Ã¶tÃ¼rÃ¼r.

@FeignClient istifadÉ™ edÉ™ bilmÉ™k Ã¼Ã§Ã¼n (iÅŸlÉ™mÉ™si Ã¼Ã§Ã¼n main classda @EnableFeignClients annotation yazmalÄ±yÄ±q) (hÉ™mÃ§inin dependency É™lavÉ™ edirik: org.springframework.cloud:spring-cloud-started-openfeign)
FeignClient-dÉ™ mÉ™nfi cÉ™hÉ™t odurki, FeignClient ilÉ™ mÉ™lumat Ã§É™kdiyimiz ms-in mÃ¼vafiq DTO-nu Ã¶z ms-zÉ™ kopyalamalÄ±yÄ±q. Tutaqki Ã¶z ms-É™ 5 fÉ™rqli ms-dÉ™n FeignClient ilÉ™ data Ã§É™kirik, data Ã§É™kÉ™ndÉ™ data Ã§É™kdiyimiz APÄ° hansÄ±sa bir responseDTO qaytarÄ±r axÄ±, hÉ™min DTO-larÄ± hÉ™min ms-lÉ™rdÉ™n kopyalamalÄ±yÄ±q. Amma bu normaldÄ±r. MikroservisdÉ™ copy paste classlarÄ±n olmasÄ± normaldÄ±r.

NiyÉ™ bÉ™zi ÅŸirkÉ™tlÉ™r Go proqramlaÅŸdÄ±rma dili iÅŸlÉ™dir. Java yox. Ã§ox adam deyir sÃ¼rÉ™tÉ™ gÃ¶rÉ™, amma yox. Kodu normal yazsaq elÉ™ Java-da da sÃ¼rÉ™tli iÅŸlÉ™yÉ™cÉ™k. DÃ¼zgÃ¼n cavab: Java, JVM memory-ni Ã§ox yeyir. Memory-yÉ™ gÃ¶rÉ™. Memory az olmasÄ± cost saving-dir. DÉ™mirlÉ™rÉ™, serverlÉ™rÉ™ az pul vermÉ™k demÉ™kdir. Go daha lightweight dildir.


@Fallback annotation (spring 6.2-dÉ™ gÉ™lib) - bir interfaceni Ã§oxlu classlar implements edÉ™ bilÉ™r. Kodu run edÉ™ndÉ™ bÉ™zÉ™n spring tam baÅŸa dÃ¼ÅŸmÉ™yÉ™ bilÉ™r ki, hansÄ± classÄ±n beanini hÉ™min interfeysÉ™ inject edim onda Ã¼zÉ™rinÉ™ @Fallback annotation yazdÄ±ÄŸÄ±mÄ±z classÄ±n beanin inject edÉ™cÉ™k. YÉ™ni @Fallback annotation bir nÃ¶v default bean iÅŸini gÃ¶rÃ¼r. @Primary, @Qualifier annotationlarÄ±na oxÅŸar iÅŸlÉ™r gÃ¶rÃ¼r

ProblemlÉ™r:
- Lost update
- Dirty read
- None repeatable read
- Phantom read

Transaction isolation layers. YuxarÄ±dan aÅŸaÄŸÄ± getdiksÉ™ tÉ™hlÃ¼kÉ™sizlik artÄ±r, amma iÅŸlÉ™mÉ™ sÃ¼rÉ™ti zÉ™iflÉ™yir. 1 vÉ™ 4 mÉ™slÉ™hÉ™t deyil. Cari keysÉ™ gÃ¶rÉ™ 2 vÉ™ ya 3 istifadÉ™ edilir
- 1. Read uncommitted (Lost update problemini hÉ™ll edir)
- 2. Read committed (dirty read problemini hÉ™ll edir) - default budur. commitdÉ™n qabaq double check edir. É™gÉ™r eyni anda eyni sÉ™tir Ã¼Ã§Ã¼n yalnÄ±z bir transaksiya iÅŸlÉ™yirsÉ™ onda bu iÅŸimizi gÃ¶rÉ™cÉ™k (Bu multithread-lÉ™rdÉ™ pozula bilÉ™r. Bu vaxt pozula bilÉ™r ki, bizÉ™ eyni vaxtda eyni user paralel olaraq birdÉ™n Ã§ox sorÄŸu gÉ™lir. Bu zaman repeatable read qoymalÄ±yÄ±q)
- 3. repetable read (non-repetable problemini hÉ™ll edir). Ã¶dÉ™niÅŸlÉ™rlÉ™ baÄŸlÄ± hallarda bu istifadÉ™ olunur. son dÉ™yÉ™ri gÃ¶tÃ¼rÃ¼r. bir nÃ¶v volatile kimi. save etmÉ™dÉ™n Ã¶ncÉ™ value-ni bir dÉ™fÉ™ dÉ™ check edir (double check). eyni anda databazadakÄ± eyni sÉ™tr Ã¼zrÉ™ paralel transaksiyalar varsa onda mÉ™cbur bunu iÅŸlÉ™tmÉ™liyik (vÉ™ ya Serializable). optimistic locking burda olur.

hÉ™mÃ§inin non-repetable read problemini manual olaraq Ã¶zÃ¼mÃ¼z hÉ™ll etmÉ™k istÉ™sÉ™k select for update buraxÄ±rÄ±q. onda manual Ã¶zÃ¼mÃ¼z update etmiÅŸ oluruq datanÄ±. select for update - variablenin state-ni baÅŸlayÄ±r izlÉ™mÉ™yÉ™. son dÉ™yÉ™ri gÃ¶tÃ¼rÃ¼r.
select for update - variablenin state-ni baÅŸlayÄ±r izlÉ™mÉ™yÉ™. son dÉ™yÉ™ri gÃ¶tÃ¼rÃ¼r. non-repetable read problemini manual olaraq Ã¶zÃ¼mÃ¼z hÉ™ll etmÉ™k istÉ™sÉ™k select for update buraxÄ±rÄ±q. onda manual Ã¶zÃ¼mÃ¼z update etmiÅŸ oluruq datanÄ±
- 4. Serializable (Phantom read yÉ™ni, bÃ¼tÃ¼n problemlÉ™ri hÉ™ll edir) - digÉ™r tranzaksiyalarÄ± fully olaraq bloklayÄ±r. É™n tÉ™hlÃ¼kÉ™siz budur, amma É™n gec iÅŸlÉ™yÉ™n dÉ™ budur. hÉ™mÃ§inin pessimistic locking burda olur

Set<Integer> set = new HashSet<>(); -> bu kod compile olunanda burdakÄ± Generics Object clasÄ±na formalaÅŸÄ±r, Ã§evrilir. Eli bil Set<E> idisÉ™ Set<Object> olur. O hÉ™rflÉ™ri ObjectÉ™ Ã§evirir. Sonra OOP-nin polimorfizim qaydasÄ±na gÃ¶rÉ™ dÉ™ ObjectÉ™ Integer dÉ™yÉ™ri mÉ™nimsÉ™dir. Buna Runtime Polimorphizim deyilir.

HashMap vs HashTable
HashMap-É™ null key É™lavÉ™ edÉ™ bilirik
HashTable-da yox

Kodda amount olan hissÉ™lÉ™rÉ™ double vÉ™ ya float yox, BigDecimal qoyun. mÃ¼tlÉ™q!!! bir Ã§ox problemin hÉ™lli Ã¼Ã§Ã¼n. doubleda misal Ã¼Ã§Ã¼n ola bilÉ™r ki 20/4 = 5.00000000001 filan versin, lazÄ±msÄ±z baÅŸaÄŸrÄ±sÄ± olan bilÉ™r

Ã§alÄ±ÅŸ databazanÄ± (postgresql, mongodb), hÉ™tta hÉ™rÅŸeyi docker-dÉ™ qaldÄ±r, yÉ™ni hÉ™rÅŸeyin ayrÄ±ca app-nÄ± tÉ™k-tÉ™k yÃ¼klÉ™mÉ™. É™vÉ™zindÉ™ dockerdÉ™ qaldÄ±r hÉ™rÅŸeyi

throw new NotFoundException("message") -> burda e yazma, Ã§Ã¼nki bu hissÉ™ user-É™ gÃ¶stÉ™rilir. full stack traceni userÉ™ Ã§Ä±xarmaq birincisi ehtiyac deyil, ikincisi tÉ™hlÃ¼kÉ™lidir. ora user oriented mesaj yazmaq lazÄ±mdÄ±r. e-ni log.error-larda, log.infor-larda yazÄ±rÄ±q. exceptionu loga yaz

@JsonInclude(USE_DEFAULTS) - bu annotation class Ã¼zÉ™rindÉ™ dÉ™ qoymaq olar, field Ã¼zÉ™rindÉ™ dÉ™. O demÉ™kdirki É™gÉ™r inputda bu parametri gÃ¶ndÉ™rmÉ™sÉ™k normalda hÉ™min parametrin dÉ™yÉ™ri bizÉ™ null gÉ™lÉ™cÉ™kdisÉ™, bunu qoyanda hÉ™min parametr null gÉ™lmir, elÉ™ classÄ±n iÃ§indÉ™ yazdÄ±ÄŸÄ±mÄ±z default value gÉ™lir.

@JsonInclude(USE_DEFAULTS)
private Integer page = 0;

@JsonInclude(USE_DEFAULTS)
private Integer count = 5;

hÉ™mÃ§inin @FieldDefaults. aÅŸaÄŸÄ±dakÄ± kod bÃ¼tÃ¼n fieldlÉ™ri final edir, tÉ™kcÉ™ email-dÉ™n baÅŸqa
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal=true)
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class Person {

    String firstname;
    String lastname;
    @NonFinal
    String email;

    // Constructor here
    // toString() here

}


.collect(Collectors.toList()) ilÉ™ .toList()-in fÉ™rqi nÉ™dir? Java yuxarÄ± versiyalarda Collectors.toList() yazanda Ã¶zÃ¼ mÉ™slÉ™hÉ™t verir ki onu toList() ilÉ™ É™vÉ™z elÉ™.
cavab: toList() immutable object qaytarÄ±r.

servisin iÅŸi yalnÄ±z biznes mÉ™ntiqi olmalÄ±dÄ±r. loglar, nÉ™bilim mapperlÉ™r, convertlÉ™r vÉ™ s hamÄ±sÄ±nÄ± Ã§Ä±xarmalÄ±yÄ±q digÉ™r classlara (util classlarÄ±na, mapper classlarÄ±na vÉ™ s)

limit offset mÉ™ntiqi niyÉ™ gec iÅŸlÉ™yir?
cavab: Ã§Ã¼nki offset 5000 yazmÄ±ÅŸÄ±qca vÉ™ limit 100 yazmÄ±ÅŸÄ±qsa, É™slindÉ™ o limit 5100 kimi iÅŸlÉ™yir, sonra 5000-i tullayÄ±b 100-Ã¼ bizÉ™ gÃ¶stÉ™rir, yÉ™ni É™slindÉ™ arxada 100 sÉ™tirlik script kimi yox 5100 sÉ™tirlik script kimi iÅŸlÉ™yir ona gÃ¶rÉ™ deyirlÉ™r paginationda limit offset mÉ™ntiqi gec iÅŸlÉ™yir.

scheduler, joblar. (iÅŸlÉ™mÉ™si Ã¼Ã§Ã¼n main classda @EnableScheduling yazmalÄ±yÄ±q) (hÉ™mÃ§inin dependency É™lavÉ™ etmÉ™liyik - net.javacrumbs.shedlock)
Scheduler joblarÄ±nÄ± Ã¶zÃ¼mÃ¼z qoyuruq ki hansÄ± vaxtlarda iÅŸlÉ™sin
SchedulerLock nÉ™ Ã¼Ã§Ã¼ndÃ¼r? - job yalnÄ±z 1 dÉ™fÉ™ (1 podda) iÅŸlÉ™tmÉ™k Ã¼Ã§Ã¼n. Biz SchedulerLock iÅŸlÉ™tmÉ™sÉ™k neÃ§É™ É™dÉ™d podumuz varsa jobumuz hÉ™min sayda iÅŸlÉ™yÉ™cÉ™k

mÃ¼tlÉ™q deyilki, Scheduler joblarÄ± Ã¼Ã§Ã¼n fixed bir vaxt qoyaq, orda sadÉ™cÉ™ qoymaq olur ki, neÃ§É™ dÉ™qiqÉ™dÉ™nbir iÅŸlÉ™sin. orda sadÉ™cÉ™ fixedDelay 15 dÉ™qiqÉ™ filan yazÄ±rÄ±q (PT15M - 15 minutes) (PT15S - 15 seconds), Ã¶zÃ¼ 15 dÉ™qiqÉ™dÉ™nbir iÅŸlÉ™yir, bir nÃ¶v fixed vaxt qoyduÄŸumuzda bunun: 0 15 * * * * alternativi kimi olmuÅŸ olur

joblar hamÄ±sÄ± eyni thread-dÉ™ iÅŸlÉ™diyinÉ™ gÃ¶rÉ™ bizdÉ™ 1 job bitmÉ™miÅŸ digÉ™ri iÅŸÉ™ dÃ¼ÅŸmÃ¼r. yÉ™ni misal Ã¼Ã§Ã¼n biz PT1S yazmÄ±ÅŸÄ±q ki hÉ™r 1 saniyÉ™dÉ™n bir iÅŸÉ™ dÃ¼ÅŸ vÉ™ methodun iÃ§É™risindÉ™ dÉ™ Thread.sleep(5 saniyÉ™) yazmÄ±ÅŸÄ±q. Onda 1 saniyÉ™dÉ™nbir yox 5 saniyÉ™dÉ™n iÅŸlÉ™yÉ™cÉ™k. ÆgÉ™r bizÉ™ mÃ¼tlÉ™q 1 saniyÉ™dÉ™nbir lazÄ±m idisÉ™ onda thread-lÉ™ri ayÄ±rmalÄ±yÄ±q. Thread-lÉ™ri necÉ™ ayÄ±rmaq olar? É™n asanÄ± job iÅŸlÉ™yÉ™n methodun É™vvÉ™linÉ™ @Async annotation yazmaq ilÉ™. (Java based digÉ™r yol Executor ServislÉ™r yazmaq)
BelÉ™liklÉ™ É™gÉ™r bizÉ™ lazÄ±mdÄ±rki bir job bitsin sonra digÉ™ri baÅŸlasÄ±n (yÉ™ni bir job bitmÉ™miÅŸ digÉ™ri baÅŸlamasÄ±n) onda heÃ§ nÉ™ etmirik Ã§Ã¼nki elÉ™ onsuzda Ã¶zÃ¼ o mÉ™ntiqlÉ™ iÅŸlÉ™yir. Amma bizÉ™ lazÄ±mdÄ±rki biz neÃ§É™ saniyÉ™dÉ™nbir qoymuÅŸuqsa elÉ™ hÉ™min vaxtlarda da iÅŸlÉ™sin onda methodun É™vvÉ™linÉ™ @Async yazmaq. Bu zaman fÉ™rqi yoxdur bir Ã¶ncÉ™ki job bitib yoxsa bitmÉ™yib ikinci job elÉ™ Ã¶z vaxtÄ±nda iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k Ã§Ã¼nki hÉ™r biri baÅŸqa baÅŸqa thread-lÉ™rdÉ™ iÅŸlÉ™yirlÉ™r.

https://crontab.guru/ = bu saytda bir az qurdalamaq olar vaxtlarÄ±

multithread appda (hansÄ± ki indi onsuzda single thread app demÉ™k olar yoxdur) tutaqki siz yazmÄ±sÄ±qki gecÉ™ saat 12-dÉ™ bir job iÅŸÉ™ dÃ¼ÅŸsÃ¼n. sizdÉ™ o job 1 dÉ™fÉ™ iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k? É™lbÉ™ttÉ™ ki yox. neÃ§É™ pod varsa o sayda iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k. biz burda bu problemi bir neÃ§É™ Ã¼sulla hÉ™ll edÉ™ bilÉ™rik:
1. SchedulerLock - Shedlock - run process in only 1 pod - instance
2. K8S (Kubernetes) Cron Jobs - jobu spring bootda yÉ™ni kodda yox, Kubernetes-dÉ™ yazÄ±rÄ±q. Kubernetes calls your API. bu da É™slindÉ™ qeyri adi bir ÅŸey deyil. biz sadÉ™cÉ™ Kubernetes-É™ controller classÄ±mÄ±zda olan hÉ™r hansÄ± bir API (url) veririk, vÉ™ deyirik tutaqki saat 12-dÉ™ bu url Ã§aÄŸÄ±r, o da Ã§aÄŸÄ±rÄ±r. Kubernetes-i bir nÃ¶v UI kimi istifadÉ™ etmiÅŸ oluruq. Kubernetes load balancer mÉ™ntiqi ilÉ™ Ã§aÄŸÄ±rÄ±r deyÉ™, sorÄŸunu yalnÄ±z 1 poda gÃ¶ndÉ™rir
3. bu joblar springdÉ™ yalnÄ±z 1 threaddÉ™ iÅŸÉ™ dÃ¼ÅŸÃ¼r deyÉ™ tutaqki sÉ™n eyni jobu 2 dÉ™fÉ™ dalbadal Ã§aÄŸÄ±rmaq istÉ™yirsÉ™n, misal Ã¼Ã§Ã¼n bir saat 12:00-da, bir dÉ™ saat 12:01-dÉ™. bunlar eyni thread-dÉ™ olduÄŸuna gÃ¶rÉ™ bir birindÉ™n asÄ±lÄ±dÄ±rlar. yÉ™ni birinci bitmÉ™sÉ™ ikinci baÅŸlamayacaq. yÉ™ni ola bilÉ™r ki, 12:01-dÉ™ (ikinci) qoyduÄŸun job hÉ™lÉ™ birinci iÅŸÉ™ dÃ¼ÅŸÉ™n Ã¶z iÅŸini bitirmÉ™yib - threadi hÉ™lÉ™ iÅŸÄŸal edib deyÉ™ iÅŸÉ™ dÃ¼ÅŸmÉ™sin.
amma yox bizÉ™ mÃ¼tlÉ™q lazÄ±mdÄ±rki neÃ§É™ dÉ™fÉ™ ora yazmÄ±ÅŸÄ±qca onlarÄ±n hamÄ±sÄ± 100% iÅŸÉ™ dÃ¼ÅŸsÃ¼n onda thread-lÉ™ri ayÄ±rmaq lazÄ±mdÄ±r. necÉ™? onu araÅŸdÄ±r.
Misal Ã¼Ã§Ã¼n @Async (iÅŸlÉ™mÉ™si Ã¼Ã§Ã¼n main classda @EnableAsync annotation yazmalÄ±yÄ±q. HÉ™mÃ§inin @Async-dÉ™ HTTPRESPONSE ACCEPTED 202 qaytarmaq mÉ™ntiqlidir)
amma @Async-i dÉ™ izlÉ™mÉ™k olmur, yÉ™ni void mÉ™ntiqi ilÉ™ iÅŸlÉ™yir bilmÉ™k olmur bitdimi yoxsa yox. ÆgÉ™r biz bitmÉ™yini dÉ™ bilmÉ™k istÉ™yiriksÉ™ onda @Async yox, completableFuture istifadÉ™ etmÉ™liyik

Asynxron prosseslÉ™rdÉ™ HTTP ResponsedÉ™ 202 ACCEPTED status code qaytarÄ±rÄ±q.
joblar default olaraq yalnÄ±z 1 threadÉ™ iÅŸlÉ™yir. yÉ™ni orda bir mÉ™ntiq var ki, bir job bitmÉ™miÅŸ ikincisi baÅŸlamÄ±r. misal Ã¼Ã§Ã¼n biz qoymuÅŸuq ki, job 1 dÉ™qiqÉ™dÉ™nbir iÅŸÉ™ dÃ¼ÅŸsÃ¼n, amma kodda Thread.sleep(5 dÉ™qiqÉ™) qoymuÅŸuq, onda jobumuz 1 dÉ™qiqÉ™dÉ™nbir iÅŸÉ™ dÃ¼ÅŸmÉ™yÉ™cÉ™k. Birinci iÅŸÉ™ dÃ¼ÅŸÉ™n bitÉ™cÉ™k 5 dÉ™qiqÉ™yÉ™. ondan sonra 1 dÉ™qiqÉ™ keÃ§É™ndÉ™n sonra ikinci dÉ™fÉ™ eyni job iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k. YÉ™ni biz 1 dÉ™qiqÉ™dÉ™nbir qoymuÅŸuq, amma faktiki jobumuz 6 dÉ™qiqÉ™dÉ™nbir iÅŸlÉ™yÉ™cÉ™k.
É™gÉ™r yox biz istÉ™sÉ™k ki, mÃ¼tlÉ™q 1 dÉ™qiqÉ™dÉ™nbir iÅŸÉ™ dÃ¼ÅŸsÃ¼n, yÉ™ni bundan Ã¶ncÉ™kinin bitmÉ™yindÉ™n asÄ±lÄ± olmayaraq, onda baÅŸqa thread qoÅŸmalÄ±yÄ±q, @Async annotation vÉ™ ya Executor ServislÉ™r (fixed thread pool) kÃ¶mÉ™yi ilÉ™


Apache Cassandra db is a NoSQL database which is the best for bulky inserts at the same time. multiple inserts.

Javada proxy ilÉ™ iÅŸlÉ™yÉ™n annotation-lar
1. @Transactional
2. @Cachable
3. @Async
4. AOP Ã¼zrÉ™ olan annotation-lar

methodun baÅŸÄ±nda @Transactional varsa vÉ™ methodun iÃ§indÉ™ @Async varsa. TutaqkÄ± @Async-lÉ™ yazdÄ±ÄŸÄ±mÄ±z servis qÄ±rÄ±lsa onda rollback gedir yoxsa yox? yÉ™ni @Transactional iÅŸÉ™ dÃ¼ÅŸmÃ¼ÅŸ olur yoxsa yox - cavab: dÃ¼ÅŸÃ¼r. yÉ™ni rollback edir hÉ™lÉ™dÉ™. O thread qÄ±rÄ±lsa digÉ™r hamÄ±sÄ±nÄ± rollback edir. Ã§Ã¼nki onlarÄ±n bir birinÉ™ tÉ™siri yoxdur. @Transactional annotation methodu 1 transaksiyaya salÄ±r, @Async isÉ™ baÅŸqa thread-É™ ayÄ±rÄ±r, amma yenÉ™ dÉ™ eyni transaksiyada qalmÄ±ÅŸ olur. YÉ™ni @Async-dÉ™ki thread qÄ±rÄ±lsa vÉ™ ya É™sas thread qÄ±rÄ±lsa hÉ™r iki halda da transaksiya rollback olunmuÅŸ olur.

CD/CI -  continuous deployment and continuous integration

CI steps - mostly used CI build servers are Jenkins (pipeline-larÄ± qura bilir), Gitlab CI/CD, Github Actions
1. Build
2. Unit test / Integration test (we can use docker here)
3. Analyse. Leaking. Memory management. Security checks. Here we use tools for finding security problems (mostly used tool: sonar)
4. Coverage (for example test coverage must be over than 80%)
5. Package - combine all codes from repository, also get all internal and external libraries and pick all of them together (mostly used tool: JFrog artifactory)

CD steps - qurduÄŸumuz packageni iÅŸlÉ™tmÉ™k
1. integration test
2. release - (mostly used tool: JFrog artifactory)
3. deploy

monitoring tool - Grafana
metric - statistika, request sayÄ± vÉ™ s

release branch nÉ™dir? (yuxarÄ±da CD steps yazÄ±lan yerdÉ™ki 2-ci mÉ™rhÉ™lÉ™) release branchÄ±n hÉ™miÅŸÉ™ versiyasÄ± olur. release deploy edilÉ™n branchdÄ±r. yÉ™ni mÃ¼ÅŸtÉ™riyÉ™ verilÉ™cÉ™k branhcdÄ±r. mÃ¼É™yyÉ™n bir vaxtdan bir (agiledirsÉ™ deyÉ™ ki hÉ™r scrum sprint bitÉ™ndÉ™) master branchÄ±ndan bir kopya yaradÄ±lÄ±b adÄ±nÄ± qoyuruq misal Ã¼Ã§Ã¼n release-1.0.10. Sonra bu release branchÄ±nÄ± integration testingÉ™ gÃ¶ndÉ™ririk baÅŸqa nÉ™ prosedurlar varsa hamÄ±sÄ±na gÃ¶ndÉ™ririk. ÆgÉ™r bu branchda bir problem aÅŸkar edilÉ™rsÉ™ vÉ™ hansÄ±sa bir dÉ™yiÅŸiklik olunarsa É™n sonra eyni dÉ™yiÅŸiklik master branhÄ±na da kÃ¶Ã§Ã¼rÃ¼lmÉ™lidir. ÆgÉ™r bÃ¼tÃ¼n testlÉ™rimiz bitdisÉ™ bu release-1.0.10 branchÄ± deploy edilir proda yÉ™ni mÃ¼ÅŸtÉ™rinin istifadÉ™sinÉ™ verilir. hÉ™mÃ§inin release-1.0.10 branchÄ± branhÄ± proda Ã§Ä±xandan sonra belÉ™ hÉ™lÉ™ ki silinmir saxlanÄ±lÄ±r gitlabda. Ã§Ã¼nki mÃ¼ÅŸtÉ™ri dÉ™ nÉ™sÉ™ test edÉ™ bilÉ™r problem yaÅŸana bilÉ™r. Bu problemlÉ™r yenÉ™ dÉ™ bu release-1.0.10 branchÄ±nda hÉ™ll edilir vÉ™ birdaha deploy edilir vÉ™ yenÉ™ bu dÉ™yiÅŸikliklÉ™r masterÉ™ dÉ™ tÉ™tbiq edilir. Bu arxitektura hÉ™r ÅŸirkÉ™tdÉ™ eyni deyil. elÉ™ ÅŸirkÉ™t ver heÃ§ release branch istifadÉ™ etmir elÉ™ hÉ™r ÅŸeyi master branchÄ± Ã¼zÉ™rindÉ™n edir.
(https://www.youtube.com/watch?v=QupPTc-_6-c)

sual: mÉ™ndÉ™ bir class var: User class iÃ§É™risindÉ™ long id, int age, String name field-lÉ™ri var. indi 10 min dÉ™nÉ™ bu class-Ä±n obyekti var. bunu age-yÉ™ gÃ¶rÉ™ necÉ™ sort edim?
cavab: birinci UserÄ±mÄ±zÄ± implements Comparator etmÉ™liyik. ikinci olaraq obyeklÉ™rimiizi treeSet gÃ¶tÃ¼rÃ¼b ora add etmÉ™liyik.
User classÄ±dÄ±rsa Comparator implements etmÉ™liyik.
Integer, String vÉ™ s classlarÄ±mÄ±z olsa indi onlarÄ±n default olaraq implements Comparator

Serialization vs DeSerialization
Serialization obyekti byte-lar ÅŸÉ™klindÉ™ saxlayÄ±r deyÉ™ yer az tutur vÉ™ hÉ™mÃ§inin daha sÃ¼rÉ™tli iÅŸlÉ™yir. AdÉ™tÉ™n datanÄ± fayla vÉ™ ya keÅŸÉ™ (RedisÉ™) yazanda yazmamÄ±ÅŸdan Ã¶ncÉ™ Serialization edib sonra yazÄ±rÄ±q vÉ™ hÉ™min obyekti dÉ™ oxuyanda DeSerialization edib oxuyuruq. HÉ™r hansÄ± bir obyekti Serialization etmÉ™k Ã¼Ã§Ã¼n mÃ¼tlÉ™q
1. implements Serializable interface (Marker interface)
2. add serialVersionUID field
private static final Long serialVersionUID = 1L;

VersiyanÄ± qabaqcadan niyÉ™ Ã¶zÃ¼mÃ¼z veririk? ÆgÉ™r bunu etmÉ™sÉ™k bunu Java Ã¶zÃ¼ bir random long versiya verÉ™cÉ™k, vÉ™ gÉ™lÉ™cÉ™kdÉ™ hÉ™min classa bir field artÄ±rmaq (vÉ™ ya silmÉ™k) istÉ™sÉ™k bunu edÉ™ bilmÉ™yÉ™cÉ™yik, Ã§Ã¼nki bu dÉ™fÉ™ dÉ™ Java ona baÅŸqa bir versiya verÉ™cÉ™k vÉ™ bizim kÃ¶hnÉ™ versiyamÄ±z ilÉ™ tÉ™zÉ™ versiyamÄ±z eyni olmadÄ±ÄŸÄ±na gÃ¶rÉ™ classÄ± Serialization DeSerialization etmÉ™k mÃ¼mkÃ¼n olmayacaq. Amma versiyanÄ± Ã¶zÃ¼mÃ¼z veririk deyÉ™ classdan istÉ™nilÉ™n bir field É™lavÉ™ edilsÉ™ (vÉ™ ya silinsÉ™) versiya yenÉ™ dÉ™ eyni qalacaq vÉ™ heÃ§ bir problem yaÅŸanmayacaq.