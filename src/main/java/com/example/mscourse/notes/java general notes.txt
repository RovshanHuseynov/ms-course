Integer a = 4;
Integer b = 4;
System.out.println(a == b); // true

Integer a = 128;
Integer b = 128;
System.out.println(a == b); // false


between -128 to 127 they are true, then they are false. byte-Ä±n tutduÄŸu yer É™n kiÃ§ikdir, bu o demÉ™kdir byte-Ä±n tutduÄŸu yer digÉ™r hamÄ±sÄ±nÄ± tutduÄŸu yerÉ™ girib yerlÉ™ÅŸÉ™ bilÉ™r. short-da yerlÉ™ÅŸÉ™ bilÉ™r, int-É™ dÉ™, long-a da. HamÄ±sÄ±na yerlÉ™ÅŸÉ™ bilir deyÉ™, onu keÅŸlÉ™yÉ™ bilir, daha bÃ¶yÃ¼k rÉ™qÉ™mlÉ™ri isÉ™ keÅŸlÉ™mir ki, onlar sonra misal Ã¼Ã§Ã¼n byte-a short-a yerlÉ™ÅŸmÉ™yÉ™ bilÉ™r

Gradle vs Maven
1. Gradle bir az daha sÃ¼rÉ™tli iÅŸlÉ™yir. Dependency-lÉ™ri daha tez gÉ™tirir (tÉ™bii ki internetin sÃ¼rÉ™ti dÉ™ burda Ã¶nÉ™mli faktordur)
2. Gradle-da Ã¶z scriptlÉ™rimizi yazmaq olur

failSafe()
failFast()
iteratorlarn fÉ™rqi
MultiThread collections
misal Ã¼Ã§Ã¼n ArrayList() yox CopyOnWriteArrayList() - bu saÄŸdakÄ±nÄ± iÅŸlÉ™dÉ™ndÉ™ bizim iterator artÄ±q failSafe olmuÅŸ olur
map yox ConcurrentHashMap. bunlar multi thread mÃ¼hittÉ™ listlÉ™rlÉ™ vÉ™ ya maplarla iÅŸlÉ™mÉ™k Ã¼Ã§Ã¼ndÃ¼r

Java 8 gÉ™lmÉ™miÅŸdÉ™n Ã¶ncÉ™ (yÉ™ni lambda gÉ™lmÉ™miÅŸdÉ™n Ã¶ncÉ™) functional interface-lÉ™r Java-ne nÉ™ vasitÉ™silÉ™ istifadÉ™ olunurdu? cavab: anynom class-lar vasitÉ™silÉ™ 
lambda expression-a int a Ã¶tÃ¼rÉ™ bilmirik, orda immutibility mÉ™sÉ™lÉ™si var, lambda expression-a effectively final variable gÃ¶ndÉ™rÉ™ bilirik. bunun mÉ™qsÉ™di variable-Ä± sadÉ™cÉ™ bir dÉ™fÉ™ istifadÉ™ etmÉ™k Ã¼Ã§Ã¼ndÃ¼r. int ona gÃ¶rÉ™ gÃ¶ndÉ™rÉ™ bilmirikki, int final deyil.

java 8-dÉ™n sonra bucket red black tree-dir linkedlist yox, amma size > 8 olandan sonra red black tree-yÉ™ Ã§evrilir, size = 8-É™ kimi linkedlist olmaÄŸa davam edir
red black tree-dÉ™ axtarÄ±ÅŸ O(log(n))-dir deyÉ™sÉ™n binary search-lÉ™r iÅŸlÉ™yir
sonra load factor default olaraq 75%-dir, onu aÅŸandan sonra bucket size 2 dÉ™fÉ™ artÄ±r (default = 16)
sual? mapdakÄ± elementlÉ™ri silsÉ™k onda bucket size azalÄ±rmÄ±? cavab: xeyr
biz mÃ¼tlÉ™q azalmasÄ±nÄ± istÉ™yiriksÉ™ onda Ã¶z hashmapÄ±mÄ±zÄ± yazmalÄ±yÄ±q. javanÄ±n standart hashmapÄ± bizÉ™ yaramÄ±r

hashlarÄ±n eyni olmasÄ±na termin olaraq kolleziya deyilir.

final vs effectively final
final-da variable qarÅŸÄ±sÄ±na final yazÄ±rÄ±q vÉ™ bilirik ki, dÉ™yÉ™r-value heÃ§ vaxt dÉ™yiÅŸmÉ™yÉ™cÉ™k
effectively final-da isÉ™ variable qarÅŸÄ±sÄ±na final yazmÄ±rÄ±q, amma dÉ™yÉ™ri bir dÉ™fÉ™ yazÄ±rÄ±q vÉ™ heÃ§ vaxt dÉ™yiÅŸmir

Amotic class-lar Ã¶zlÉ™ri arxada volatile keyword istifadÉ™ edirlÉ™r, yÉ™ni dÉ™yÉ™ri keÅŸdÉ™n Ram-dan gÃ¶tÃ¼rÃ¼r. MultiThread-dÉ™ mÉ™cbur Atomic variable iÅŸlÉ™tmÉ™liyik, Ã§Ã¼nki multi thread-dÉ™ int onsuz da iÅŸlÉ™mÉ™yÉ™cÉ™k.

iterator vs listiterator

in listiterator, you can:
- iterate backwards
- obtain the iterator at any point.
- add a new value at any point.
- set a new value at that point.

With iterator you can move only forward, but with ListIterator you can move backword also while reading the elements.
With ListIterator you can obtain the index at any point while traversing, which is not possible with iterators.
With iterator you can check only for next element available or not, but in listiterator you can check previous and next elements.
With listiterator you can add new element at any point of time, while traversing. Not possible with iterator.
With listiterator you can modify an element while traversing, which is not possible with iterator.

Atomic classlar multi thread applarda mÃ¼tlÉ™q ki, istifadÉ™ olunmalÄ±dÄ±r vÉ™ onlar arxa planda Ã¶zlÉ™ri multi thread Ã¼Ã§Ã¼n nÉ™zÉ™rdÉ™ tutulub. Misal Ã¼Ã§Ã¼n orda volatile istifadÉ™ olunub. YÉ™ni dÉ™yÉ™rlÉ™r keÅŸdÉ™n yox birbaÅŸa RAM-dan gÃ¶tÃ¼rÃ¼lÃ¼r. Multi thread appda biz bu atomic classlarÄ±n obyektini iÅŸlÉ™tmÉ™liyik.
Misal Ã¼Ã§Ã¼n deyÉ™k ki, tiktokda iki meyxanaÃ§Ä± canlÄ± yayÄ±mda meyxana deyib yarÄ±ÅŸÄ±rlar vÉ™ sÉ™n dÉ™ kimi dÉ™stÉ™klÉ™yirsÉ™nsÉ™ girib o meyxanaÃ§Ä±ya sÉ™s verirsÉ™n. DeyÉ™k ki, hÉ™r meyxanaÃ§Ä± Ã¼Ã§Ã¼n dÉ™ ekranda 1 É™dÉ™d dÃ¼ymÉ™ var. "MexyanaÃ§Ä±A-ni dÉ™skÉ™tlÉ™!" "MexyanaÃ§Ä±B-ni dÉ™skÉ™tlÉ™!" adÄ±nda 2 É™dÉ™d button var. Ä°ndi canlÄ± yayÄ±mda minlÉ™rlÉ™ istifadÉ™Ã§i o dÃ¼ymÉ™lÉ™ri girib klik edirlÉ™r vÉ™ hÉ™r meyxanaÃ§Ä±ya neÃ§É™ nÉ™fÉ™r sÉ™s verib biz onu hesablamalÄ±yÄ±q. DeyÉ™k ki, bizim int cnt = 0; dÉ™yiÅŸÉ™nimiz var hÉ™r azarkeÅŸ klik edÉ™ndÉ™ cnt++ yazÄ±rÄ±q. Multi thread appda tÉ™bii ki bu iÅŸlÉ™mÉ™yÉ™cÉ™k, eyni anda iki vÉ™ daha Ã§ox azarkeÅŸ klik etsÉ™ vsyo bizim cnt keÅŸdÉ™n gÃ¶tÃ¼rÉ™cÉ™k tutaq ki 10 nÉ™fÉ™r eyni ayna klik edÉ™ndÉ™ amma bizim cnt 1 vahid vÉ™ ya nÉ™bilim 3 vahid artmÄ±ÅŸ olacaq, halbuki 10 vahid artmalÄ± idi. Burda mÃ¼tlÉ™q ki, AtomicInteger iÅŸlÉ™tmÉ™li idik onda o Ã¶zÃ¼ volatile istifadÉ™ edir deyÉ™ eyni anda neÃ§É™ nÉ™fÉ™r dÉ™ klik etsÉ™ o sayda increment olacaqdÄ±.

AtomicInteger nÉ™ zaman istifadÉ™ edilÉ™ bilir? multithreadingdÉ™. shared datamÄ±z varsa. stackda saxlanmayan datadÄ±rsa yani method iÃ§indÉ™ki variabledirsÉ™ ehtiyac deyil bunlarda, amma classda É™n yuxarÄ±da (methodlardan da yuxarÄ±da) olan variabledÄ±rsa onda lazÄ±mdÄ±r. Ã§Ã¼nki onlar arxada volatile iÅŸlÉ™dir, methodlarÄ± safe methodlardÄ±r, yÉ™ni mÉ™lumatÄ± keÅŸdÉ™n yox RAMdan gÃ¶tÃ¼rÃ¼r


Volatile-nin dÉ™ demiÅŸdik mÉ™nfi cÉ™hÉ™ti oldurki nisbÉ™tÉ™n zÉ™if sÃ¼rÉ™tdÉ™ iÅŸlÉ™yirlÉ™r, amma Multi thread applarda onlarÄ± iÅŸlÉ™tmÉ™yÉ™ mÉ™cburuq, baÅŸqa yolumuz yoxdur onsuzda. ÆslindÉ™ AtomicInteger int-É™ nisbÉ™tdÉ™ bÉ™li gec iÅŸlÉ™yir, amma onun kodunu elÉ™ optimal yazÄ±blarki É™slindÉ™ o qÉ™dÉ™r dÉ™ gec iÅŸlÉ™mir, yÉ™ni iÅŸimizi gÃ¶rÃ¼r, problem yoxdur.

Volatile Ã¼Ã§Ã¼n internetdÉ™ qÉ™ÅŸÉ™ng nÃ¼munÉ™ var ki, biz tutaqki evdÉ™ oturmuÅŸuq divanda pivÉ™ iÃ§mÉ™k istÉ™yirik. YanÄ±mÄ±zda balaca soyuducular olur ee portable, ondan var onun iÃ§indÉ™ pivÉ™ var, onu gÃ¶tÃ¼rÃ¼b iÃ§irik. Bu birinci hal. Sonra mÉ™tbÉ™xdÉ™ soyuducuda da pivÉ™ var onu da gedib gÉ™tirib iÃ§É™ bilÉ™rdik. Bu ikinci hal. Bir dÉ™ Ã§Ã¶ldÉ™ yaxÄ±nlÄ±qda market var orda da soyuducuda pivÉ™ satÄ±rlar gedib onu alÄ±b onu da iÃ§É™ bilÉ™rdik. Bu Ã¼Ã§Ã¼ncÃ¼ hal. Ä°nternetdÉ™ki nÃ¼munÉ™dÉ™ deyirdiki biz kodda volatile yazanda gedib pivÉ™ni o Ã§Ã¶ldÉ™ki marketdÉ™ki soyuducudan gÉ™tirir, yÉ™ni uzaqdan gÉ™tirir RAM-dan. O nÃ¼munÉ™dÉ™ keÅŸ isÉ™ bizim yanÄ±mÄ±zda onu xÄ±rda portable soyuducu idi ğŸ˜€

HansÄ± class-Ä±n obyektini yaratmaq olmur? - Abstract class
Constructoru var? - var
niyÉ™? - Ã§Ã¼nki onu extend edÉ™n class-Ä±n obyekti yaradÄ±landa hÉ™min classÄ±n constructoru iÅŸÉ™ dÃ¼ÅŸÃ¼r vÉ™ inheritance qaydasÄ±na gÃ¶rÉ™ hÉ™min constructorun iÃ§É™risindÉ™ abstract classÄ±n constructoru da iÅŸÉ™ dÃ¼ÅŸmÉ™lidir

bir class-Ä± immutable etmÉ™k Ã¼Ã§Ã¼n nÉ™ etmÉ™k lazÄ±mdÄ±r?
1. classÄ± final elÉ™
2. field-lÉ™r private
3. setter-lÉ™ri yÄ±ÄŸÄ±ÅŸdÄ±r
4. getter-lÉ™rdÉ™ É™gÉ™r mutable obyekt qayÄ±dÄ±rsa onu clonlayÄ±rÄ±q. SÉ™bÉ™bi dÉ™ odurki, É™gÉ™r obyekti girib dÉ™yiÅŸsÉ™lÉ™r belÉ™ bizÉ™ tÉ™sir etmÉ™yÉ™cÉ™k, Ã§Ã¼nki biz obyektin Ã¶zÃ¼nÃ¼ yox clonunu qaytarÄ±rÄ±q

constructoru private harda etmÉ™k olar?
1. singleton class-larda
2. constant class-larda. yalnÄ±z field-lÉ™r olur onlarda da public static final olur. Class-Ä±n obyektini yaratmaÄŸa ehtiyac olmur

try with resources - exception handling zamanÄ± istifadÉ™ olunur. finally block-unu avtomatik Ã¶zÃ¼ icra edir, amma yalnÄ±z AutoClonable interface-sini implements edÉ™n resursdursa onda try with resources istifadÉ™ edÉ™ bilirik.

Thread yaratmaÄŸÄ±n hansÄ± Ã¼sullarÄ± var?
1. Thread classÄ±ndan extends etmÉ™k
2. Runnable interface implements etmÉ™k
3. Callable interface implements etmÉ™k
Runnable ilÉ™ Callable nÉ™ fÉ™rqi var? qaytardÄ±ÄŸÄ± tipdÉ™ fÉ™rqi var
HÉ™r ikisi functional interfacedir, yÉ™ni yalnÄ±z 1 É™dÉ™d abstract methodu var
Runnable interface-dÉ™ki hÉ™min o method void-dir yÉ™ni dÉ™yÉ™r qaytarmÄ±r
Callable interface-dÉ™ki method isÉ™ Future obyekt qaytarÄ±r. Bunda threadi buraxandan sonra cavabÄ± izlÉ™mÉ™k olur, axÄ±rÄ± nÉ™ oldu bilmÉ™k olur
Completable Future in Java AraÅŸdÄ±r

current table-ya index qoysaq cÉ™dvÉ™l lock olacaq. gÉ™rÉ™k gecÉ™ serveri sÃ¶ndÃ¼rÃ¼b qoyaq neÃ§É™ saat production iÅŸlÉ™mÉ™sin. postgresql-dÉ™ asyncron index var, cÉ™dvÉ™li lock etmÉ™miÅŸ index qoyur
primary key vÉ™ unique constraintlÉ™ri avtomatik index yaradÄ±r
serial vÉ™ bigserial Ã¶zÃ¼ndÉ™ increment saxlayÄ±r

Transaction
ACID principles:
1. Atomicity - ya transaction fully olaraq keÃ§mÉ™lidir, fully rollback olmalÄ±dÄ±r
2. Consistency - data consistentliyi pozulmamalÄ±dÄ±r, cÉ™dvÉ™llÉ™r - tÉ™rÉ™flÉ™r arasÄ±nda state eyni qalmalÄ±dÄ±r, pozulmamalÄ±dÄ±r, yÉ™ni bir tÉ™rÉ™fdÉ™ status CompleteddirsÉ™, digÉ™r tÉ™rÉ™fdÉ™ dÉ™ completed olmalÄ±dÄ±r vÉ™ ya bir tÉ™rÉ™fdÉ™ mÉ™blÉ™ÄŸ 5 manatdÄ±rsa digÉ™r tÉ™rÉ™fdÉ™ dÉ™ 5 manat olmaldÄ±r. Misal Ã¼Ã§Ã¼n sÉ™n 5 manat gÃ¶ndÉ™rdin, qarÅŸÄ± tÉ™rÉ™fÉ™ 6 manat getdi Ã§atdÄ± bu o demÉ™kdirki consistency pozulub
3. Isolation - kÉ™nar mÃ¼daxilÉ™ olmamalÄ±dÄ±r, digÉ™r bir transaksiya filan bura qoÅŸulmamalÄ±dÄ±r. DigÉ™r É™mÉ™liyyat varsa ikinci bir transaksiya kimi edilmÉ™lidir
4. Durability - safe ÅŸÉ™kildÉ™ proses bitir. bir transaction commit olunubsa yÉ™ni proses bitibsÉ™ artÄ±q bu andan sonra bu transaksiya barÉ™sindÉ™ heÃ§ bir dÉ™yiÅŸiklik edilÉ™ bilmÉ™z, rollback oluna bilmÉ™z vÉ™ s.
Sual: Durability nÉ™ vaxt pozula bilÉ™r? bir nÃ¼munÉ™ de. Cavab: Databaza hÉ™miÅŸÉ™ bir É™dÉ™d olmur. Bizim yazdÄ±ÄŸÄ±mÄ±z master databazadÄ±r, amma onun replicasiyasÄ± olur, standy filan olur. buna Sharding deyilir. Durability belÉ™ pozula bilÉ™r ki, biz master db-yÉ™ yazdÄ±q OK cavabÄ±nÄ± aldÄ±q, elÉ™ bildik bizim transaksiya bitdi. Amma hÉ™min data standy-a dÃ¼ÅŸmÉ™disÉ™ onda durability pozulmuÅŸ olur. Replicasiya mÉ™ntiqi 2 cÃ¼r ola bilÉ™r. Sinxron vÉ™ Asinxron. Durability-ni pozmamaq Ã¼Ã§Ã¼n biz replicasiya mÉ™ntiqini sinxron qoymalÄ±yÄ±q.

Active Profile. misal Ã¼Ã§Ã¼n necÉ™ etmÉ™k olar ki, local profile-dÉ™ feign-dÉ™ki url-i Ã§aÄŸÄ±rmasÄ±n. É™vÉ™zindÉ™ nÉ™sÉ™ static bir ÅŸey qaytarsÄ±n?
Feign client bir interface olduÄŸuna gÃ¶rÉ™ tÉ™zÉ™ bir mock class yazadÄ±b feign interface-ni implements edib (tÉ™bii ki classÄ± springÉ™ bean kimi tanÄ±tdÄ±rmaq Ã¼Ã§Ã¼n yuxarÄ±ya @Component yazmaq Ã§ox vacibdir), hÉ™min mock class-da feign interfacedÉ™ki methodumuzun eynisini override ilÉ™ Ã§aÄŸÄ±rÄ±b, return static data qaytara bilÉ™rik. Misal Ã¼Ã§Ã¼n return data type Student idisÉ™, return Student.builder().name("test).surname("test").build(); yaza bilÉ™rik. belÉ™ olanda hÉ™min class-Ä±n Ã¼stÃ¼nÉ™ @Profile("local") yazÄ±rÄ±q, feign interface-yÉ™ isÉ™ @Profile("!local") yazÄ±rÄ±q

@Fallback annotation (spring 6.2-dÉ™ gÉ™lib) - bir interfaceni Ã§oxlu classlar implements edÉ™ bilÉ™r. Kodu run edÉ™ndÉ™ bÉ™zÉ™n spring tam baÅŸa dÃ¼ÅŸmÉ™yÉ™ bilÉ™r ki, hansÄ±sÄ± classÄ±n beanini hÉ™min interfeysÉ™ inject edim onda Ã¼zÉ™rinÉ™ @Fallback annotation yazdÄ±ÄŸÄ±mÄ±z classÄ±n beanin inject edÉ™cÉ™k. YÉ™ni @Fallback annotation bir nÃ¶v default bean iÅŸini gÃ¶rÃ¼r. @Primary, @Qualifier annotationlarÄ±na oxÅŸar iÅŸlÉ™r gÃ¶rÃ¼r

ProblemlÉ™r:
- Lost update
- Dirty read
- None repeatable read
- Phantom read

Transaction isolation layers. YuxarÄ±dan aÅŸaÄŸÄ± getdiksÉ™ tÉ™hlÃ¼kÉ™sizlik artÄ±r, amma iÅŸlÉ™mÉ™ sÃ¼rÉ™ti zÉ™iflÉ™yir. 1 vÉ™ 4 mÉ™slÉ™hÉ™t deyil. Cari keysÉ™ gÃ¶rÉ™ 2 vÉ™ ya 3 istifadÉ™ edilir
- 1. Read uncommitted
- 2. Read committed (dirty read problemini hÉ™ll edir) - default budur. commitdÉ™n qabaq double check edir. É™gÉ™r eyni anda eyni sÉ™tir Ã¼Ã§Ã¼n yalnÄ±z bir transaksiya iÅŸlÉ™yirsÉ™ onda bu iÅŸimizi gÃ¶rÉ™cÉ™k
- 3. repetable read (non-repetable problemini hÉ™ll edir). Ã¶dÉ™niÅŸlÉ™rlÉ™ baÄŸlÄ± hallarda bu istifadÉ™ olunur. son dÉ™yÉ™ri gÃ¶tÃ¼rÃ¼r. bir nÃ¶v volatile kimi. save etmÉ™dÉ™n Ã¶ncÉ™ value-ni bir dÉ™fÉ™ dÉ™ check edir (double check). eyni anda databazadakÄ± eyni sÉ™tr Ã¼zrÉ™ paralel transaksiyalar varsa onda mÉ™cbur bunu iÅŸlÉ™tmÉ™liyik (vÉ™ ya Serializable). optimistic locking burda olur.

hÉ™mÃ§inin non-repetable read problemini manual olaraq Ã¶zÃ¼mÃ¼z hÉ™ll etmÉ™k istÉ™sÉ™k select for update buraxÄ±rÄ±q. onda manual Ã¶zÃ¼mÃ¼z update etmiÅŸ oluruq datanÄ±. select for update - variablenin state-ni baÅŸlayÄ±r izlÉ™mÉ™yÉ™. son dÉ™yÉ™ri gÃ¶tÃ¼rÃ¼r.
select for update - variablenin state-ni baÅŸlayÄ±r izlÉ™mÉ™yÉ™. son dÉ™yÉ™ri gÃ¶tÃ¼rÃ¼r. non-repetable read problemini manual olaraq Ã¶zÃ¼mÃ¼z hÉ™ll etmÉ™k istÉ™sÉ™k select for update buraxÄ±rÄ±q. onda manual Ã¶zÃ¼mÃ¼z update etmiÅŸ oluruq datanÄ±
- 4. Serializable (bÃ¼tÃ¼n problemlÉ™ri hÉ™ll edir) - digÉ™r tranzaksiyalarÄ± fully olaraq bloklayÄ±r. É™n tÉ™hlÃ¼kÉ™siz budur, amma É™n gec iÅŸlÉ™yÉ™n dÉ™ budur. hÉ™mÃ§inin pessimistic locking burda olur

Set<Integer> set = new HashSet<>(); -> bu kod compile olunanda burdakÄ± Generics Object clasÄ±na formalaÅŸÄ±r, Ã§evrilir. Eli bil Set<E> idisÉ™ Set<Object> olur. O hÉ™rflÉ™ri ObjectÉ™ Ã§evirir. Sonra OOP-nin polimorfizim qaydasÄ±na gÃ¶rÉ™ dÉ™ ObjectÉ™ Integer dÉ™yÉ™ri mÉ™nimsÉ™dir. Buna Runtime Polimorphizim deyilir.

HashMap vs HashTable
HashMap-É™ null key É™lavÉ™ edÉ™ bilirik
HashTable-da yox

Kodda amount olan hissÉ™lÉ™rÉ™ double vÉ™ ya float yox, BigDecimal qoyun. mÃ¼tlÉ™q!!! bir Ã§ox problemin hÉ™lli Ã¼Ã§Ã¼n. doubleda misal Ã¼Ã§Ã¼n ola bilÉ™r ki 20/4 = 5.00000000001 filan versin, lazÄ±msÄ±z baÅŸaÄŸrÄ±sÄ± olan bilÉ™r

Ã§alÄ±ÅŸ databazanÄ± (postgresql, mongodb), hÉ™tta hÉ™rÅŸeyi docker-dÉ™ qaldÄ±r, yÉ™ni hÉ™rÅŸeyin ayrÄ±ca app-nÄ± tÉ™k-tÉ™k yÃ¼klÉ™mÉ™. É™vÉ™zindÉ™ dockerdÉ™ qaldÄ±r hÉ™rÅŸeyi

throw new NotFoundException("message") -> burda e yazma, Ã§Ã¼nki bu hissÉ™ user-É™ gÃ¶stÉ™rilir. full stack traceni userÉ™ Ã§Ä±xarmaq birincisi ehtiyac deyil, ikincisi tÉ™hlÃ¼kÉ™lidir. ora user oriented mesaj yazmaq lazÄ±mdÄ±r. e-ni log.error-larda, log.infor-larda yazÄ±rÄ±q. exceptionu loga yaz

@JsonInclude(USE_DEFAULTS) - bu annotation class Ã¼zÉ™rindÉ™ dÉ™ qoymaq olar, field Ã¼zÉ™rindÉ™ dÉ™. O demÉ™kdirki É™gÉ™r inputda bu parametri gÃ¶ndÉ™rmÉ™sÉ™k normalda hÉ™min parametrin dÉ™yÉ™ri bizÉ™ null gÉ™lÉ™cÉ™kdisÉ™, bunu qoyanda hÉ™min parametr null gÉ™lmir, elÉ™ classÄ±n iÃ§indÉ™ yazdÄ±ÄŸÄ±mÄ±z default value gÉ™lir.

@JsonInclude(USE_DEFAULTS)
private Integer page = 0;

@JsonInclude(USE_DEFAULTS)
private Integer count = 5;

hÉ™mÃ§inin @FieldDefaults. aÅŸaÄŸÄ±dakÄ± kod bÃ¼tÃ¼n fieldlÉ™ri final edir, tÉ™kcÉ™ email-dÉ™n baÅŸqa
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal=true)
@FieldDefaults(level = AccessLevel.PRIVATE, makeFinal = true)
public class Person {

    String firstname;
    String lastname;
    @NonFinal
    String email;

    // Constructor here
    // toString() here

}


.collect(Collectors.toList()) ilÉ™ .toList()-in fÉ™rqi nÉ™dir? Java yuxarÄ± versiyalarda Collectors.toList() yazanda Ã¶zÃ¼ mÉ™slÉ™hÉ™t verir ki onu toList() ilÉ™ É™vÉ™z elÉ™.
cavab: toList() immutable object qaytarÄ±r.

servisin iÅŸi yalnÄ±z biznes mÉ™ntiqi olmalÄ±dÄ±r. loglar, nÉ™bilim mapperlÉ™r, convertlÉ™r vÉ™ s hamÄ±sÄ±nÄ± Ã§Ä±xarmalÄ±yÄ±q digÉ™r classlara (util classlarÄ±na, mapper classlarÄ±na vÉ™ s)

limit offset mÉ™ntiqi niyÉ™ gec iÅŸlÉ™yir?
cavab: Ã§Ã¼nki offset 5000 yazmÄ±ÅŸÄ±qca vÉ™ limit 100 yazmÄ±ÅŸÄ±qsa, É™slindÉ™ o limit 5100 kimi iÅŸlÉ™yir, sonra 5000-i tullayÄ±b 100-Ã¼ bizÉ™ gÃ¶stÉ™rir, yÉ™ni É™slindÉ™ arxada 100 sÉ™tirlik script kimi yox 5100 sÉ™tirlik script kimi iÅŸlÉ™yir ona gÃ¶rÉ™ deyirlÉ™r paginationda limit offset mÉ™ntiqi gec iÅŸlÉ™yir.

scheduler, joblar.
Scheduler joblarÄ±nÄ± Ã¶zÃ¼mÃ¼z qoyuruq ki hansÄ± vaxtlarda iÅŸlÉ™sin
SchedulerLock nÉ™ Ã¼Ã§Ã¼ndÃ¼r? - job yalnÄ±z 1 dÉ™fÉ™ (1 podda) iÅŸlÉ™tmÉ™k Ã¼Ã§Ã¼n. Biz SchedulerLock iÅŸlÉ™tmÉ™sÉ™k boÅŸda neÃ§É™ É™dÉ™d podumuz varsa jobumuz hÉ™min sayda iÅŸlÉ™yÉ™cÉ™k

mÃ¼tlÉ™q deyilki, Scheduler joblarÄ± Ã¼Ã§Ã¼n fixed bir vaxt qoyaq, orda sadÉ™cÉ™ qoymaq olur ki, neÃ§É™ dÉ™qiqÉ™dÉ™nbir iÅŸlÉ™sin. orda sadÉ™cÉ™ fixedDelay 15 dÉ™qiqÉ™ filan yazÄ±rÄ±q, Ã¶zÃ¼ 15 dÉ™qiqÉ™dÉ™nbir iÅŸlÉ™yir, bir nÃ¶v fixed vaxt qoyduÄŸumuzda bunun: 0 15 * * * * alternativi kimi olmuÅŸ olur

https://crontab.guru/ = bu saytda bir az qurdalamaq olar vaxtlarÄ±

multithread appda (hansÄ± ki indi onsuzda single thread app demÉ™k olar yoxdur) tutaqki siz yazmÄ±sÄ±qki gecÉ™ saat 12-dÉ™ bir job iÅŸÉ™ dÃ¼ÅŸsÃ¼n. sizdÉ™ o job 1 dÉ™fÉ™ iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k? É™lbÉ™ttÉ™ ki yox. neÃ§É™ pod varsa o sayda iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k. biz burda bu problemi bir neÃ§É™ Ã¼sulla hÉ™ll edÉ™ bilÉ™rik:
1. SchedulerLock - Shedlock - run process in only 1 pod - instance
2. K8S (Kubernetes) Cron Jobs - jobu spring bootda yÉ™ni kodda yox, Kubernetes-dÉ™ yazÄ±rÄ±q. Kubernetes calls your API. bu da É™slindÉ™ qeyri adi bir ÅŸey deyil. biz sadÉ™cÉ™ Kubernetes-É™ controller classÄ±mÄ±zda olan hÉ™r hansÄ± bir API (url) veririk, vÉ™ deyirik tutaqki saat 12-dÉ™ bu url Ã§aÄŸÄ±r, o da Ã§aÄŸÄ±rÄ±r. Kubernetes-i bir nÃ¶v UI kimi istifadÉ™ etmiÅŸ oluruq. Kubernetes load balancer mÉ™ntiqi ilÉ™ Ã§aÄŸÄ±rÄ±r deyÉ™, sorÄŸunu yalnÄ±z 1 poda gÃ¶ndÉ™rir
3. bu joblar springdÉ™ yalnÄ±z 1 threaddÉ™ iÅŸÉ™ dÃ¼ÅŸÃ¼r deyÉ™ tutaqki sÉ™n eyni jobu 2 dÉ™fÉ™ dalbadal Ã§aÄŸÄ±rmaq istÉ™yirsÉ™n, misal Ã¼Ã§Ã¼n bir saat 12:00-da, bir dÉ™ saat 12:01-dÉ™. bunlar eyni thread-dÉ™ olduÄŸuna gÃ¶rÉ™ bir birindÉ™n asÄ±lÄ±dÄ±rlar. yÉ™ni birinci bitmÉ™sÉ™ ikinci baÅŸlamayacaq. yÉ™ni ola bilÉ™r ki, 12:01-dÉ™ (ikinci) qoyduÄŸun job hÉ™lÉ™ birinci iÅŸÉ™ dÃ¼ÅŸÉ™n Ã¶z iÅŸini bitirmÉ™yib - threadi hÉ™lÉ™ iÅŸÄŸal edib deyÉ™ iÅŸÉ™ dÃ¼ÅŸmÉ™sin.
amma yox bizÉ™ mÃ¼tlÉ™q lazÄ±mdÄ±rki neÃ§É™ dÉ™fÉ™ ora yazmÄ±ÅŸÄ±qca onlarÄ±n hamÄ±sÄ± 100% iÅŸÉ™ dÃ¼ÅŸsÃ¼n onda thread-lÉ™ri ayÄ±rmaq lazÄ±mdÄ±r. necÉ™? onu araÅŸdÄ±r.
Misal Ã¼Ã§Ã¼n @Async

Asynxron prosseslÉ™rdÉ™ HTTP ResponsedÉ™ 202 ACCEPTED status code qaytarÄ±rÄ±q.
joblar default olaraq yalnÄ±z 1 threadÉ™ iÅŸlÉ™yir. yÉ™ni orda bir mÉ™ntiq var ki, bir job bitmÉ™miÅŸ ikincisi baÅŸlamÄ±r. misal Ã¼Ã§Ã¼n biz qoymuÅŸuq ki, job 1 dÉ™qiqÉ™dÉ™nbir iÅŸÉ™ dÃ¼ÅŸsÃ¼n, amma kodda Thread.sleep(5 dÉ™qiqÉ™) qoymuÅŸuq, onda jobumuz 1 dÉ™qiqÉ™dÉ™nbir iÅŸÉ™ dÃ¼ÅŸmÉ™yÉ™cÉ™k. Birinci iÅŸÉ™ dÃ¼ÅŸÉ™n bitÉ™cÉ™k 5 dÉ™qiqÉ™yÉ™. ondan sonra 1 dÉ™qiqÉ™ keÃ§É™ndÉ™n sonra ikinci dÉ™fÉ™ eyni job iÅŸÉ™ dÃ¼ÅŸÉ™cÉ™k. YÉ™ni biz 1 dÉ™qiqÉ™dÉ™nbir qoymuÅŸuq, amma faktiki jobumuz 6 dÉ™qiqÉ™dÉ™nbir iÅŸlÉ™yÉ™cÉ™k.
É™gÉ™r yox biz istÉ™sÉ™k ki, mÃ¼tlÉ™q 1 dÉ™qiqÉ™dÉ™nbir iÅŸÉ™ dÃ¼ÅŸsÃ¼n, yÉ™ni bundan Ã¶ncÉ™kinin bitmÉ™yindÉ™n asÄ±lÄ± olmayaraq, onda baÅŸqa thread qoÅŸmalÄ±yÄ±q, @Async annotation vÉ™ ya Executor ServislÉ™r (fixed thread pool) kÃ¶mÉ™yi ilÉ™


Apache Cassandra db is a NoSQL database which is the best for bulky inserts at the same time. multiple inserts.

Javada proxy ilÉ™ iÅŸlÉ™yÉ™n annotation-lar
1. @Transactional
2. @Cachable
3. @Async
4. AOP Ã¼zrÉ™ olan annotation-lar

methodun baÅŸÄ±nda @Transactional varsa vÉ™ methodun iÃ§indÉ™ @Async varsa. TutaqkÄ± @Async-lÉ™ yazdÄ±ÄŸÄ±mÄ±z servis qÄ±rÄ±lsa onda rollback gedir yoxsa yox? yÉ™ni @Transactional iÅŸÉ™ dÃ¼ÅŸmÃ¼ÅŸ olur yoxsa yox - cavab: dÃ¼ÅŸÃ¼r


testing:
unit
contract
penetration
load
stress
integration


mock - 95%
stub
spy