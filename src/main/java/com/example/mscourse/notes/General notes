Integer a = 4;
Integer b = 4;
System.out.println(a == b); // true

Integer a = 128;
Integer b = 128;
System.out.println(a == b); // false


between -128 to 127 they are true, then they are false. byte-ın tutduğu yer ən kiçikdir, bu o deməkdir byte-ın tutduğu yer digər hamısını tutduğu yerə girib yerləşə bilər. short-da yerləşə bilər, int-ə də, long-a da. Hamısına yerləşə bilir deyə, onu keşləyə bilir, daha böyük rəqəmləri isə keşləmir ki, onlar sonra misal üçün byte-a short-a yerləşməyə bilər

failSafe()
failFast()
iteratorlarn fərqi
MultiThread collections
misal üçün ArrayList() yox CopyOnWriteArrayList() - bu sağdakını işlədəndə bizim iterator artıq failSafe olmuş olur
map yox ConcurrentHashMap. bunlar multi thread mühittə listlərlə və ya maplarla işləmək üçündür

Java 8 gəlməmişdən öncə (yəni lambda gəlməmişdən öncə) functional interface-lər Java-ne nə vasitəsilə istifadə olunurdu? cavab: anynom class-lar vasitəsilə
lambda expression-a int a ötürə bilmirik, orda immutibility məsələsi var, lambda expression-a effectively final variable göndərə bilirik. bunun məqsədi variable-ı sadəcə bir dəfə istifadə etmək üçündür. int ona görə göndərə bilmirikki, int final deyil.

java 8-dən sonra bucket red black tree-dir linkedlist yox, amma size > 8 olandan sonra red black tree-yə çevrilir, size = 8-ə kimi linkedlist olmağa davam edir
red black tree-də axtarış O(log(n))-dir deyəsən binary search-lər işləyir
sonra load factor default olaraq 75%-dir, onu aşandan sonra bucket size 2 dəfə artır (default = 16)
sual? mapdakı elementləri silsək onda bucket size azalırmı? cavab: xeyr

hashların eyni olmasına termin olaraq kolleziya deyilir.

final vs effectively final
final-da variable qarşısına final yazırıq və bilirik ki, dəyər-value heç vaxt dəyişməyəcək
effectively final-da isə variable qarşısına final yazmırıq, amma dəyəri bir dəfə yazırıq və heç vaxt dəyişmir

Amotic class-lar özləri arxada volatile keyword istifadə edirlər, yəni dəyəri keşdən Ram-dan götürür. MultiThread-də məcbur Atomic variable işlətməliyik, çünki multi thread-də int onsuz da işləməyəcək.

iterator vs listiterator

in listiterator, you can:
- iterate backwards
- obtain the iterator at any point.
- add a new value at any point.
- set a new value at that point.

With iterator you can move only forward, but with ListIterator you can move backword also while reading the elements.
With ListIterator you can obtain the index at any point while traversing, which is not possible with iterators.
With iterator you can check only for next element available or not, but in listiterator you can check previous and next elements.
With listiterator you can add new element at any point of time, while traversing. Not possible with iterator.
With listiterator you can modify an element while traversing, which is not possible with iterator.


Atomic classlar multi thread applarda mütləq ki, istifadə olunmalıdır və onlar arxa planda özləri multi thread üçün nəzərdə tutulub. Misal üçün orda volatile istifadə olunub. Yəni dəyərlər keşdən yox birbaşa RAM-dan götürülür. Multi thread appda biz bu atomic classların obyektini işlətməliyik.
Misal üçün deyək ki, tiktokda iki meyxanaçı canlı yayımda meyxana deyib yarışırlar və sən də kimi dəstəkləyirsənsə girib o meyxanaçıya səs verirsən. Deyək ki, hər meyxanaçı üçün də ekranda 1 ədəd düymə var. "MexyanaçıA-ni dəskətlə!" "MexyanaçıB-ni dəskətlə!" adında 2 ədəd button var. İndi canlı yayımda minlərlə istifadəçi o düymələri girib klik edirlər və hər meyxanaçıya neçə nəfər səs verib biz onu hesablamalıyıq. Deyək ki, bizim int cnt = 0; dəyişənimiz var hər azarkeş klik edəndə cnt++ yazırıq. Multi thread appda təbii ki bu işləməyəcək, eyni anda iki və daha çox azarkeş klik etsə vsyo bizim cnt keşdən götürəcək tutaq ki 10 nəfər eyni ayna klik edəndə amma bizim cnt 1 vahid və ya nəbilim 3 vahid artmış olacaq, halbuki 10 vahid artmalı idi. Burda mütləq ki, AtomicInteger işlətməli idik onda o özü volatile istifadə edir deyə eyni anda neçə nəfər də klik etsə o sayda increment olacaqdı.

Volatile-nin də demişdik mənfi cəhəti oldurki nisbətən zəif sürətdə işləyirlər, amma Multi thread applarda onları işlətməyə məcburuq, başqa yolumuz yoxdur onsuzda. Əslində AtomicInteger int-ə nisbətdə bəli gec işləyir, amma onun kodunu elə optimal yazıblarki əslində o qədər də gec işləmir, yəni işimizi görür, problem yoxdur.

Volatile üçün internetdə qəşəng nümunə var ki, biz tutaqki evdə oturmuşuq divanda pivə içmək istəyirik. Yanımızda balaca soyuducular olur ee portable, ondan var onun içində pivə var, onu götürüb içirik. Bu birinci hal. Sonra mətbəxdə soyuducuda da pivə var onu da gedib gətirib içə bilərdik. Bu ikinci hal. Bir də çöldə yaxınlıqda market var orda da soyuducuda pivə satırlar gedib onu alıb onu da içə bilərdik. Bu üçüncü hal. İnternetdəki nümunədə deyirdiki biz kodda volatile yazanda gedib pivəni o çöldəki marketdəki soyuducudan gətirir, yəni uzaqdan gətirir RAM-dan. O nümunədə keş isə bizim yanımızda onu xırda portable soyuducu idi 😀

Hansı class-ın obyektini yaratmaq olmur? - Abstract class
Constructoru var? - var
niyə? - çünki onu extend edən class-ın obyekti yaradılanda həmin classın constructoru işə düşür və inheritance qaydasına görə həmin constructorun içərisində abstract classın constructoru da işə düşməlidir

bir class-ı immutable etmək üçün nə etmək lazımdır?
1. classı final elə
2. field-lər private
3. setter-ləri yığışdır
4. getter-lərdə əgər mutable obyekt qayıdırsa onu clonlayırıq. Səbəbi də odurki, əgər obyekti girib dəyişsələr belə bizə təsir etməyəcək, çünki biz obyektin özünü yox clonunu qaytarırıq

constructoru private harda etmək olar?
1. singleton class-larda
2. constant class-larda. yalnız field-lər olur onlarda da public static final olur. Class-ın obyektini yaratmağa ehtiyac olmur

try with resources - exception handling zamanı istifadə olunur. finally block-unu avtomatik özü icra edir, amma yalnız AutoClonable interface-sini implements edən resursdursa onda try with resources istifadə edə bilirik.

Thread yaratmağın hansı üsulları var?
Runnable var
Callable var
Runnable ilə Callable nə fərqi var? qaytardığı tipdə fərqi var
Runnable yalnız void methodu var
Callable isə threadi buraxandan sonra izləmək olur, axırı nə oldu bilmək olur