failSafe()
failFast()
iteratorlarn fÉ™rqi
MultiThread collections
misal Ã¼Ã§Ã¼n ArrayList() yox CopyOnWriteArrayList() - bu saÄŸdakÄ±nÄ± iÅŸlÉ™dÉ™ndÉ™ bizim iterator artÄ±q failSafe olmuÅŸ olur
map yox ConcurrentHashMap. bunlar multi thread mÃ¼hittÉ™ listlÉ™rlÉ™ vÉ™ ya maplarla iÅŸlÉ™mÉ™k Ã¼Ã§Ã¼ndÃ¼r

Java 8 gÉ™lmÉ™miÅŸdÉ™n Ã¶ncÉ™ (yÉ™ni lambda gÉ™lmÉ™miÅŸdÉ™n Ã¶ncÉ™) functional interface-lÉ™r Java-ne nÉ™ vasitÉ™silÉ™ istifadÉ™ olunurdu? cavab: anynom class-lar vasitÉ™silÉ™
lambda expression-a int a Ã¶tÃ¼rÉ™ bilmirik, orda immutibility mÉ™sÉ™lÉ™si var, lambda expression-a effectively final variable gÃ¶ndÉ™rÉ™ bilirik. bunun mÉ™qsÉ™di variable-Ä± sadÉ™cÉ™ bir dÉ™fÉ™ istifadÉ™ etmÉ™k Ã¼Ã§Ã¼ndÃ¼r. int ona gÃ¶rÉ™ gÃ¶ndÉ™rÉ™ bilmirikki, int final deyil.

final vs effectively final
final-da variable qarÅŸÄ±sÄ±na final yazÄ±rÄ±q vÉ™ bilirik ki, dÉ™yÉ™r-value heÃ§ vaxt dÉ™yiÅŸmÉ™yÉ™cÉ™k
effectively final-da isÉ™ variable qarÅŸÄ±sÄ±na final yazmÄ±rÄ±q, amma dÉ™yÉ™ri bir dÉ™fÉ™ yazÄ±rÄ±q vÉ™ heÃ§ vaxt dÉ™yiÅŸmir

Amotic class-lar Ã¶zlÉ™ri arxada volatile keyword istifadÉ™ edirlÉ™r, yÉ™ni dÉ™yÉ™ri keÅŸdÉ™n Ram-dan gÃ¶tÃ¼rÃ¼r. MultiThread-dÉ™ mÉ™cbur Atomic variable iÅŸlÉ™tmÉ™liyik, Ã§Ã¼nki multi thread-dÉ™ int onsuz da iÅŸlÉ™mÉ™yÉ™cÉ™k.

iterator vs listiterator

in listiterator, you can:
- iterate backwards
- obtain the iterator at any point.
- add a new value at any point.
- set a new value at that point.

With iterator you can move only forward, but with ListIterator you can move backword also while reading the elements.
With ListIterator you can obtain the index at any point while traversing, which is not possible with iterators.
With iterator you can check only for next element available or not, but in listiterator you can check previous and next elements.
With listiterator you can add new element at any point of time, while traversing. Not possible with iterator.
With listiterator you can modify an element while traversing, which is not possible with iterator.


Atomic classlar multi thread applarda mÃ¼tlÉ™q ki, istifadÉ™ olunmalÄ±dÄ±r vÉ™ onlar arxa planda Ã¶zlÉ™ri multi thread Ã¼Ã§Ã¼n nÉ™zÉ™rdÉ™ tutulub. Misal Ã¼Ã§Ã¼n orda volatile istifadÉ™ olunub. YÉ™ni dÉ™yÉ™rlÉ™r keÅŸdÉ™n yox birbaÅŸa RAM-dan gÃ¶tÃ¼rÃ¼lÃ¼r. Multi thread appda biz bu atomic classlarÄ±n obyektini iÅŸlÉ™tmÉ™liyik.
Misal Ã¼Ã§Ã¼n deyÉ™k ki, tiktokda iki meyxanaÃ§Ä± canlÄ± yayÄ±mda meyxana deyib yarÄ±ÅŸÄ±rlar vÉ™ sÉ™n dÉ™ kimi dÉ™stÉ™klÉ™yirsÉ™nsÉ™ girib o meyxanaÃ§Ä±ya sÉ™s verirsÉ™n. DeyÉ™k ki, hÉ™r meyxanaÃ§Ä± Ã¼Ã§Ã¼n dÉ™ ekranda 1 É™dÉ™d dÃ¼ymÉ™ var. "MexyanaÃ§Ä±A-ni dÉ™skÉ™tlÉ™!" "MexyanaÃ§Ä±B-ni dÉ™skÉ™tlÉ™!" adÄ±nda 2 É™dÉ™d button var. Ä°ndi canlÄ± yayÄ±mda minlÉ™rlÉ™ istifadÉ™Ã§i o dÃ¼ymÉ™lÉ™ri girib klik edirlÉ™r vÉ™ hÉ™r meyxanaÃ§Ä±ya neÃ§É™ nÉ™fÉ™r sÉ™s verib biz onu hesablamalÄ±yÄ±q. DeyÉ™k ki, bizim int cnt = 0; dÉ™yiÅŸÉ™nimiz var hÉ™r azarkeÅŸ klik edÉ™ndÉ™ cnt++ yazÄ±rÄ±q. Multi thread appda tÉ™bii ki bu iÅŸlÉ™mÉ™yÉ™cÉ™k, eyni anda iki vÉ™ daha Ã§ox azarkeÅŸ klik etsÉ™ vsyo bizim cnt keÅŸdÉ™n gÃ¶tÃ¼rÉ™cÉ™k tutaq ki 10 nÉ™fÉ™r eyni ayna klik edÉ™ndÉ™ amma bizim cnt 1 vahid vÉ™ ya nÉ™bilim 3 vahid artmÄ±ÅŸ olacaq, halbuki 10 vahid artmalÄ± idi. Burda mÃ¼tlÉ™q ki, AtomicInteger iÅŸlÉ™tmÉ™li idik onda o Ã¶zÃ¼ volatile istifadÉ™ edir deyÉ™ eyni anda neÃ§É™ nÉ™fÉ™r dÉ™ klik etsÉ™ o sayda increment olacaqdÄ±.

Volatile-nin dÉ™ demiÅŸdik mÉ™nfi cÉ™hÉ™ti oldurki nisbÉ™tÉ™n zÉ™if sÃ¼rÉ™tdÉ™ iÅŸlÉ™yirlÉ™r, amma Multi thread applarda onlarÄ± iÅŸlÉ™tmÉ™yÉ™ mÉ™cburuq, baÅŸqa yolumuz yoxdur onsuzda. ÆslindÉ™ AtomicInteger int-É™ nisbÉ™tdÉ™ bÉ™li gec iÅŸlÉ™yir, amma onun kodunu elÉ™ optimal yazÄ±blarki É™slindÉ™ o qÉ™dÉ™r dÉ™ gec iÅŸlÉ™mir, yÉ™ni iÅŸimizi gÃ¶rÃ¼r, problem yoxdur.

Volatile Ã¼Ã§Ã¼n internetdÉ™ qÉ™ÅŸÉ™ng nÃ¼munÉ™ var ki, biz tutaqki evdÉ™ oturmuÅŸuq divanda pivÉ™ iÃ§mÉ™k istÉ™yirik. YanÄ±mÄ±zda balaca soyuducular olur ee portable, ondan var onun iÃ§indÉ™ pivÉ™ var, onu gÃ¶tÃ¼rÃ¼b iÃ§irik. Bu birinci hal. Sonra mÉ™tbÉ™xdÉ™ soyuducuda da pivÉ™ var onu da gedib gÉ™tirib iÃ§É™ bilÉ™rdik. Bu ikinci hal. Bir dÉ™ Ã§Ã¶ldÉ™ yaxÄ±nlÄ±qda market var orda da soyuducuda pivÉ™ satÄ±rlar gedib onu alÄ±b onu da iÃ§É™ bilÉ™rdik. Bu Ã¼Ã§Ã¼ncÃ¼ hal. Ä°nternetdÉ™ki nÃ¼munÉ™dÉ™ deyirdiki biz kodda volatile yazanda gedib pivÉ™ni o Ã§Ã¶ldÉ™ki marketdÉ™ki soyuducudan gÉ™tirir, yÉ™ni uzaqdan gÉ™tirir RAM-dan. O nÃ¼munÉ™dÉ™ keÅŸ isÉ™ bizim yanÄ±mÄ±zda onu xÄ±rda portable soyuducu idi ğŸ˜€

HansÄ± class-Ä±n obyektini yaratmaq olmur? - Abstract class
Constructoru var? - var
niyÉ™? - Ã§Ã¼nki onu extend edÉ™n class-Ä±n obyekti yaradÄ±landa hÉ™min classÄ±n constructoru iÅŸÉ™ dÃ¼ÅŸÃ¼r vÉ™ inheritance qaydasÄ±na gÃ¶rÉ™ hÉ™min constructorun iÃ§É™risindÉ™ abstract classÄ±n constructoru da iÅŸÉ™ dÃ¼ÅŸmÉ™lidir

bir class-Ä± immutable etmÉ™k Ã¼Ã§Ã¼n nÉ™ etmÉ™k lazÄ±mdÄ±r?
1. classÄ± final elÉ™
2. field-lÉ™r private
3. setter-lÉ™ri yÄ±ÄŸÄ±ÅŸdÄ±r
4. getter-lÉ™rdÉ™ É™gÉ™r mutable obyekt qayÄ±dÄ±rsa onu clonlayÄ±rÄ±q. SÉ™bÉ™bi dÉ™ odurki, É™gÉ™r obyekti girib dÉ™yiÅŸsÉ™lÉ™r belÉ™ bizÉ™ tÉ™sir etmÉ™yÉ™cÉ™k, Ã§Ã¼nki biz obyektin Ã¶zÃ¼nÃ¼ yox clonunu qaytarÄ±rÄ±q

constructoru private harda etmÉ™k olar?
1. singleton class-larda
2. constant class-larda. yalnÄ±z field-lÉ™r olur onlarda da public static final olur. Class-Ä±n obyektini yaratmaÄŸa ehtiyac olmur